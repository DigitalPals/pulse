{% extends "base.html" %}

{% block title %}Console - Cybex Pulse{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <!-- System Information Cards -->
            <div class="card">
                <div class="card-header">
                    <h3>System Console</h3>
                    <span id="last-updated">Last updated: <span id="update-time-text" class="update-time-text">Just now</span></span>
                </div>
                <div class="grid">
                    <!-- CPU Card -->
                    <div class="stat-card">
                        <div class="stat-icon"><i class="fas fa-microchip"></i></div>
                        <h4>CPU load</h4>
                        <div class="stat-value" id="cpu-usage">{{ system_info.cpu.normalized_load_avg[0]|int if system_info.cpu.normalized_load_avg else system_info.cpu.percent|int }}%</div>
                        <div class="progress-container">
                            <div class="progress-bar" id="cpu-progress" style="width: {{ system_info.cpu.normalized_load_avg[0]|int if system_info.cpu.normalized_load_avg else system_info.cpu.percent|int }}%"></div>
                        </div>
                        <div class="stat-detail">
                            <small>{{ system_info.cpu.count }} cores | {{ system_info.cpu.model }}</small>
                        </div>
                    </div>
                    
                    <!-- Memory Card -->
                    <div class="stat-card">
                        <div class="stat-icon"><i class="fas fa-memory"></i></div>
                        <h4>Memory usage</h4>
                        <div class="stat-value" id="memory-usage">{{ system_info.memory.percent|int }}%</div>
                        <div class="progress-container">
                            <div class="progress-bar" id="memory-progress" style="width: {{ system_info.memory.percent|int }}%"></div>
                        </div>
                        <div class="stat-detail">
                            <small>{{ (system_info.memory.used / 1024 / 1024 / 1024)|round(1) }} GB / {{ (system_info.memory.total / 1024 / 1024 / 1024)|round(1) }} GB</small>
                        </div>
                    </div>
                    
                    <!-- Disk Card -->
                    <div class="stat-card">
                        <div class="stat-icon"><i class="fas fa-hdd"></i></div>
                        <h4>Disk usage</h4>
                        <div class="stat-value" id="disk-usage">{{ system_info.disk.percent|int }}%</div>
                        <div class="progress-container">
                            <div class="progress-bar" id="disk-progress" style="width: {{ system_info.disk.percent|int }}%"></div>
                        </div>
                        <div class="stat-detail">
                            <small>{{ (system_info.disk.used / 1024 / 1024 / 1024)|round(1) if system_info.disk.used else 0 }} GB / {{ (system_info.disk.total / 1024 / 1024 / 1024)|round(1) if system_info.disk.total else 0 }} GB</small>
                        </div>
                    </div>
                </div>
            </div>
            </div>
            
            <!-- Console Output Card -->
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <div class="d-flex align-items-center">
                        <h5 class="mb-0 mr-3">Console Output</h5>
                        <span id="console-status" class="badge badge-primary ml-2">Connected</span>
                    </div>
                    <div class="console-controls">
                        <div class="console-filter">
                            <select id="log-level-filter" class="form-control form-control-sm">
                                <option value="all">All logs</option>
                                <option value="error">Errors only</option>
                                <option value="warning">Warnings only</option>
                                <option value="info">Info only</option>
                            </select>
                        </div>
                        <div class="console-search">
                            <input type="text" id="console-search" class="form-control form-control-sm" placeholder="Search logs...">
                            <button id="search-btn" class="btn btn-sm btn-secondary">
                                <i class="fas fa-search"></i>
                            </button>
                        </div>
                        <div class="autoscroll-toggle">
                            <label class="toggle-switch">
                                <input type="checkbox" id="autoscroll-toggle" checked>
                                <span class="toggle-slider"></span>
                            </label>
                            <span class="toggle-label">Auto-scroll</span>
                        </div>
                    </div>
                </div>
                <div class="card-body">
                    <div id="console-output" class="bg-dark text-light p-3 rounded console-container">
                        <div class="text-muted console-message">Connecting to console stream...</div>
                    </div>
                </div>
                <div class="card-footer">
                    <div class="d-flex justify-content-between">
                        <div>
                            <button id="clear-btn" class="btn btn-secondary">
                                <i class="fas fa-trash"></i> Clear Console
                            </button>
                            <button id="export-btn" class="btn btn-secondary ml-2">
                                <i class="fas fa-download"></i> Export Logs
                            </button>
                        </div>
                        <button id="back-btn" class="btn btn-secondary" onclick="window.location.href='/'">
                            <i class="fas fa-arrow-left"></i> Back to Dashboard
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Custom styles for console page -->
<style>
    .card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    #last-updated {
        font-size: 0.9rem;
        color: var(--text-muted);
    }
    
    .update-time-text {
        font-weight: 500;
    }
    
    .update-time-normal {
        color: var(--text-color);
    }
    
    .update-time-warning {
        color: var(--yellow);
    }
    
    .progress-container {
        width: 100%;
        height: 8px;
        background-color: var(--border-color);
        border-radius: 4px;
        margin: 10px 0;
        overflow: hidden;
    }
    
    .progress-bar {
        height: 100%;
        border-radius: 4px;
        transition: width 0.5s ease-in-out;
    }
    
    /* Use solid colors instead of gradients for better performance */
    #cpu-progress {
        background-color: var(--green);
    }
    
    #memory-progress {
        background-color: var(--green);
    }
    
    #disk-progress {
        background-color: var(--green);
    }
    
    .console-container {
        height: 500px;
        overflow-y: auto;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        line-height: 1.5;
        padding: 15px;
        position: relative;
    }
    
    .console-message {
        padding: 3px 5px;
        border-radius: 2px;
        margin-bottom: 2px;
        position: relative;
        white-space: pre-wrap;
        word-break: break-word;
    }
    
    .console-message:hover {
        background-color: rgba(255, 255, 255, 0.05);
    }
    
    .console-message.error {
        color: var(--red);
        background-color: rgba(217, 58, 58, 0.1);
        border-left: 3px solid var(--red);
        padding-left: 8px;
    }
    
    .console-message.warning {
        color: var(--yellow);
        background-color: rgba(255, 193, 7, 0.1);
        border-left: 3px solid var(--yellow);
        padding-left: 8px;
    }
    
    .console-message.info {
        color: var(--highlight-blue);
        border-left: 3px solid var(--highlight-blue);
        padding-left: 8px;
    }
    
    .console-message .timestamp {
        color: var(--text-muted);
        font-size: 0.85em;
        margin-right: 8px;
    }
    
    .console-controls {
        display: flex;
        align-items: center;
        gap: 15px;
    }
    
    .console-search {
        display: flex;
        align-items: center;
    }
    
    .console-search input {
        width: 200px;
        margin-right: 5px;
    }
    
    .autoscroll-toggle {
        display: flex;
        align-items: center;
    }
    
    .autoscroll-toggle .toggle-switch {
        margin-right: 5px;
    }
    .highlight {
        background-color: rgba(255, 193, 7, 0.3);
        color: white;
        border-radius: 2px;
        padding: 0 2px;
    }
    
    /* Restart notification styling */
    #restart-notification {
        position: sticky;
        top: 0;
        z-index: 100;
        margin-bottom: 10px;
        padding: 10px;
        border-radius: 4px;
        background-color: rgba(255, 193, 7, 0.2);
        border: 1px solid var(--yellow);
    }
    
    
    @media (max-width: 768px) {
        .console-controls {
            flex-direction: column;
            align-items: flex-start;
            gap: 10px;
            margin-top: 10px;
        }
        
        .console-search input {
            width: 150px;
        }
        
        .card-header {
            flex-direction: column;
            align-items: flex-start;
        }
        
        .console-filter, .console-search {
            width: 100%;
        }
    }
</style>
{% endblock %}

{% block scripts %}
<script src="/static/js/console-stream.js"></script>
<script type="module">
    // Console module - Refactored for better organization and performance
    const ConsoleApp = (function() {
        // Configuration constants
        const CONFIG = {
            MAX_MESSAGES: 500,
            SYSTEM_INFO_REFRESH_INTERVAL: 10000,
            LAST_UPDATED_REFRESH_INTERVAL: 30000,
            AVAILABILITY_CHECK_INTERVAL: 5000,
            MAX_RECONNECT_DELAY: 30000,
            MAX_RECONNECT_ATTEMPTS: 30,
            INITIAL_STREAM_DELAY: 500
        };
        
        // State variables
        let consoleEventSource = null;
        let autoScroll = true;
        let allMessages = [];
        let currentFilter = 'all';
        let searchTerm = '';
        let streamInitialized = false;
        let restartDetected = false;
        let availabilityCheckInterval = null;
        let reconnectAttempts = 0;
    
        // DOM element cache
        const DOM = {
            elements: {},
            
            // Initialize and cache DOM elements
            init() {
                this.elements = {
                    // System info elements
                    cpuUsage: document.getElementById('cpu-usage'),
                    cpuProgress: document.getElementById('cpu-progress'),
                    cpuDetail: document.querySelector('.stat-card:first-child .stat-detail small'),
                    memoryUsage: document.getElementById('memory-usage'),
                    memoryProgress: document.getElementById('memory-progress'),
                    memoryDetail: document.querySelector('.stat-card:nth-child(2) .stat-detail small'),
                    diskUsage: document.getElementById('disk-usage'),
                    diskProgress: document.getElementById('disk-progress'),
                    diskDetail: document.querySelector('.stat-card:nth-child(3) .stat-detail small'),
                    
                    // Console elements
                    consoleOutput: document.getElementById('console-output'),
                    consoleStatus: document.getElementById('console-status'),
                    logLevelFilter: document.getElementById('log-level-filter'),
                    consoleSearch: document.getElementById('console-search'),
                    searchBtn: document.getElementById('search-btn'),
                    autoscrollToggle: document.getElementById('autoscroll-toggle'),
                    clearBtn: document.getElementById('clear-btn'),
                    exportBtn: document.getElementById('export-btn'),
                    updateTimeText: document.getElementById('update-time-text')
                };
                
                return this.elements;
            },
            
            // Get a cached element or query it if not cached
            get(id) {
                return this.elements[id] || document.getElementById(id);
            }
        };
        
        // Initialize the application
        function init() {
            // Cache DOM elements
            DOM.init();
            
            // Set up event listeners
            setupEventListeners();
            // Initialize system info
            SystemInfo.init();
            
            // Initialize console stream with a slight delay
            setTimeout(() => {
                // Connect to the console stream
                connectToConsoleStream();
                streamInitialized = true;
                scrollToBottom();
            }, CONFIG.INITIAL_STREAM_DELAY);
            }, CONFIG.INITIAL_STREAM_DELAY);
        }
        
        // Set up event listeners for controls
        function setupEventListeners() {
            const elements = DOM.elements;
            
            // Log level filter
            elements.logLevelFilter.addEventListener('change', () => {
                currentFilter = elements.logLevelFilter.value;
                refreshConsoleDisplay();
            });
            
            // Search input
            elements.consoleSearch.addEventListener('input', () => {
                searchTerm = elements.consoleSearch.value.trim();
                refreshConsoleDisplay();
            });
            
            // Search button
            elements.searchBtn.addEventListener('click', () => {
                searchTerm = elements.consoleSearch.value.trim();
                refreshConsoleDisplay();
            });
            
            // Search on enter key
            elements.consoleSearch.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') {
                    searchTerm = elements.consoleSearch.value.trim();
                    refreshConsoleDisplay();
                }
            });
            
            // Auto-scroll toggle
            elements.autoscrollToggle.addEventListener('change', (e) => {
                autoScroll = e.target.checked;
                if (autoScroll) {
                    scrollToBottom();
                }
            });
            
            // Clear console button
            elements.clearBtn.addEventListener('click', clearConsole);
            
            // Export logs button
            elements.exportBtn.addEventListener('click', exportLogs);
            
            // Console scrolling
            setupScrollHandling();
        }
        
        function setupScrollHandling() {
            const consoleOutput = DOM.elements.consoleOutput;
            if (!consoleOutput) return;
            
            // Variables to track user scrolling vs. content additions
            let lastScrollHeight = 0;
            let userScrolledUp = false;
            let scrollTimeout = null;
            
            // Initialize the last scroll height
            setTimeout(() => {
                lastScrollHeight = consoleOutput.scrollHeight;
            }, 500);
            
            consoleOutput.addEventListener('scroll', function() {
                // Clear any pending scroll timeout
                if (scrollTimeout) {
                    clearTimeout(scrollTimeout);
                }
                
                // Calculate how far from the bottom we are
                const scrollBottom = consoleOutput.scrollHeight - consoleOutput.scrollTop - consoleOutput.clientHeight;
                
                // If the scroll height hasn't changed, this is a user-initiated scroll
                if (consoleOutput.scrollHeight === lastScrollHeight) {
                    // User scrolled up if we're more than 50px from bottom
                    userScrolledUp = scrollBottom > 50;
                    
                    // If user scrolled up, disable auto-scroll
                    if (userScrolledUp && autoScroll) {
                        DOM.elements.autoscrollToggle.checked = false;
                        autoScroll = false;
                    }
                    
                    // If user scrolled to bottom, re-enable auto-scroll if toggle is checked
                    if (scrollBottom < 10 && !autoScroll && DOM.elements.autoscrollToggle.checked) {
                        autoScroll = true;
                    }
                } else {
                    // Content was added, update the last scroll height
                    lastScrollHeight = consoleOutput.scrollHeight;
                    
                    // If auto-scroll is enabled, scroll to bottom after a short delay
                    if (autoScroll) {
                        scrollTimeout = setTimeout(scrollToBottom, 50);
                    }
                }
            });
        }
        
        // System information module
        const SystemInfo = {
            refreshInProgress: false,
            
            // Initialize system info display
            init() {
                this.refresh();
                setInterval(() => this.refresh(), CONFIG.SYSTEM_INFO_REFRESH_INTERVAL);
                
                // Initialize last updated time
                this.updateLastUpdated();
                setInterval(() => this.updateLastUpdated(), CONFIG.LAST_UPDATED_REFRESH_INTERVAL);
                
                // Initialize progress bars
                this.updateProgressBars();
            },
            
            // Refresh system information from API
            refresh() {
                if (this.refreshInProgress) return;
                
                this.refreshInProgress = true;
                
                // Fetch data from separate endpoints for better performance
                Promise.all([
                    fetch('/api/system-info/cpu').then(response => response.json()),
                    fetch('/api/system-info/memory').then(response => response.json()),
                    fetch('/api/system-info/disk').then(response => response.json())
                ])
                .then(([cpuData, memoryData, diskData]) => {
                    const data = { cpu: cpuData, memory: memoryData, disk: diskData };
                    this.updateCards(data);
                    this.updateProgressBars();
                    this.updateLastUpdated();
                    this.refreshInProgress = false;
                })
                .catch(error => {
                    console.error('Error fetching system info:', error);
                    this.refreshInProgress = false;
                    setTimeout(() => this.refresh(), 5000);
                });
            },
            
            // Update the "last updated" time display
            updateLastUpdated() {
                const updateTimeElement = DOM.get('updateTimeText');
                if (!updateTimeElement) return;
                
                const now = new Date();
                const lastUpdate = window.lastUpdateTime || now;
                window.lastUpdateTime = now;
                
                const diffInSeconds = Math.floor((now - lastUpdate) / 1000);
                
                let text = 'Just now';
                let className = 'update-time-normal';
                
                if (diffInSeconds < 60) {
                    text = 'Just now';
                } else if (diffInSeconds < 300) {
                    text = 'Less than 5 minutes ago';
                } else {
                    text = 'Over 5 minutes ago';
                    className = 'update-time-warning';
                }
                
                updateTimeElement.textContent = text;
                updateTimeElement.className = 'update-time-text ' + className;
            },
            
            // Update system info cards with new data
            updateCards(data) {
                const elements = DOM.elements;
                
                // Update CPU info
                if (data.cpu) {
                    const cpuValue = data.cpu.normalized_load_avg ?
                        data.cpu.normalized_load_avg[0] : data.cpu.percent;
                    const cpuRounded = Math.round(cpuValue);
                    
                    if (elements.cpuUsage) elements.cpuUsage.textContent = cpuRounded + '%';
                    if (elements.cpuProgress) elements.cpuProgress.style.width = cpuRounded + '%';
                    
                    if (elements.cpuDetail && data.cpu.count && data.cpu.model) {
                        elements.cpuDetail.textContent = `${data.cpu.count} cores | ${data.cpu.model}`;
                    }
                }
                
                // Update Memory info
                if (data.memory) {
                    const memRounded = Math.round(data.memory.percent);
                    
                    if (elements.memoryUsage) elements.memoryUsage.textContent = memRounded + '%';
                    if (elements.memoryProgress) elements.memoryProgress.style.width = memRounded + '%';
                    
                    if (elements.memoryDetail && data.memory.used && data.memory.total) {
                        const usedGB = (data.memory.used / 1024 / 1024 / 1024).toFixed(1);
                        const totalGB = (data.memory.total / 1024 / 1024 / 1024).toFixed(1);
                        elements.memoryDetail.textContent = `${usedGB} GB / ${totalGB} GB`;
                    }
                }
                
                // Update Disk info
                if (data.disk) {
                    const diskRounded = Math.round(data.disk.percent);
                    
                    if (elements.diskUsage) elements.diskUsage.textContent = diskRounded + '%';
                    if (elements.diskProgress) elements.diskProgress.style.width = diskRounded + '%';
                    
                    if (elements.diskDetail && data.disk.used && data.disk.total) {
                        const usedGB = (data.disk.used / 1024 / 1024 / 1024).toFixed(1);
                        const totalGB = (data.disk.total / 1024 / 1024 / 1024).toFixed(1);
                        elements.diskDetail.textContent = `${usedGB} GB / ${totalGB} GB`;
                    }
                }
            },
            
            // Update progress bar colors based on values
            updateProgressBars() {
                const elements = DOM.elements;
                
                const updateBarColor = (bar, value) => {
                    if (!bar) return;
                    
                    if (value < 50) {
                        bar.style.backgroundColor = 'var(--green)';
                    } else if (value < 80) {
                        bar.style.backgroundColor = 'var(--yellow)';
                    } else {
                        bar.style.backgroundColor = 'var(--red)';
                    }
                };
                
                // Get current values
                const cpuValue = parseInt(elements.cpuProgress?.style.width) || 0;
                const memoryValue = parseInt(elements.memoryProgress?.style.width) || 0;
                const diskValue = parseInt(elements.diskProgress?.style.width) || 0;
                
                // Update colors
                updateBarColor(elements.cpuProgress, cpuValue);
                updateBarColor(elements.memoryProgress, memoryValue);
                updateBarColor(elements.diskProgress, diskValue);
            }
        };
    
    // Function to update the "last updated" time
    function updateLastUpdated() {
        const updateTimeElement = document.getElementById('update-time-text');
        const now = new Date();
        const lastUpdate = window.lastUpdateTime || now;
        window.lastUpdateTime = now;
        
        const diffInSeconds = Math.floor((now - lastUpdate) / 1000);
        
        let text = 'Just now';
        let className = 'update-time-normal';
        
        if (diffInSeconds < 60) {
            text = 'Just now';
        } else if (diffInSeconds < 300) {
            text = 'Less than 5 minutes ago';
        } else {
            text = 'Over 5 minutes ago';
            className = 'update-time-warning';
        }
        
        updateTimeElement.textContent = text;
        updateTimeElement.className = 'update-time-text ' + className;
    }
    
    // Cache DOM elements for better performance
    let domElements = {};
    
    // Function to cache DOM elements on page load
    function cacheDOMElements() {
        domElements = {
            cpuUsage: document.getElementById('cpu-usage'),
            cpuProgress: document.getElementById('cpu-progress'),
            cpuDetail: document.querySelector('.stat-card:first-child .stat-detail small'),
            memoryUsage: document.getElementById('memory-usage'),
            memoryProgress: document.getElementById('memory-progress'),
            memoryDetail: document.querySelector('.stat-card:nth-child(2) .stat-detail small'),
            diskUsage: document.getElementById('disk-usage'),
            diskProgress: document.getElementById('disk-progress'),
            diskDetail: document.querySelector('.stat-card:nth-child(3) .stat-detail small'),
            uptimeValue: document.getElementById('uptime-value')
        };
    }
    
    // Function to refresh system information with debouncing and parallel requests
    let refreshInProgress = false;
    function refreshSystemInfo() {
        // Prevent multiple simultaneous requests
        if (refreshInProgress) return;
        
        refreshInProgress = true;
        
        // Use separate API endpoints for each metric to reduce load
        // This allows partial updates if one endpoint is slow
        Promise.all([
            fetch('/api/system-info/cpu').then(response => response.json()),
            fetch('/api/system-info/memory').then(response => response.json()),
            fetch('/api/system-info/disk').then(response => response.json())
        ])
        .then(([cpuData, memoryData, diskData]) => {
            // Combine the data
            const data = {
                cpu: cpuData,
                memory: memoryData,
                disk: diskData
            };
            
            updateSystemInfoCards(data);
            updateProgressBars();
            updateLastUpdated();
            refreshInProgress = false;
        })
        .catch(error => {
            console.error('Error fetching system info:', error);
            refreshInProgress = false;
            
            // Schedule a retry after a delay
            setTimeout(refreshSystemInfo, 5000);
        });
    }
    
    // Function to update system information cards
    function updateSystemInfoCards(data) {
        // Ensure DOM elements are cached
        if (!domElements.cpuUsage) {
            cacheDOMElements();
        }
        
        // Update CPU card with 1-minute load average (rounded to integer)
        if (data.cpu) {
            const cpuValue = data.cpu.normalized_load_avg ? data.cpu.normalized_load_avg[0] : data.cpu.percent;
            const cpuRounded = Math.round(cpuValue);
            
            if (domElements.cpuUsage) domElements.cpuUsage.textContent = cpuRounded + '%';
            if (domElements.cpuProgress) domElements.cpuProgress.style.width = cpuRounded + '%';
            
            // Update CPU details
            if (domElements.cpuDetail && data.cpu.count && data.cpu.model) {
                domElements.cpuDetail.textContent = `${data.cpu.count} cores | ${data.cpu.model}`;
            }
        }
        
        // Update Memory card (rounded to integer)
        if (data.memory) {
            const memRounded = Math.round(data.memory.percent);
            
            if (domElements.memoryUsage) domElements.memoryUsage.textContent = memRounded + '%';
            if (domElements.memoryProgress) domElements.memoryProgress.style.width = memRounded + '%';
            
            // Update memory details
            if (domElements.memoryDetail && data.memory.used && data.memory.total) {
                const usedGB = (data.memory.used / 1024 / 1024 / 1024).toFixed(1);
                const totalGB = (data.memory.total / 1024 / 1024 / 1024).toFixed(1);
                domElements.memoryDetail.textContent = `${usedGB} GB / ${totalGB} GB`;
            }
        }
        
        // Update Disk card (rounded to integer)
        if (data.disk) {
            const diskRounded = Math.round(data.disk.percent);
            
            if (domElements.diskUsage) domElements.diskUsage.textContent = diskRounded + '%';
            if (domElements.diskProgress) domElements.diskProgress.style.width = diskRounded + '%';
            
            // Update disk details
            if (domElements.diskDetail && data.disk.used && data.disk.total) {
                const usedGB = (data.disk.used / 1024 / 1024 / 1024).toFixed(1);
                const totalGB = (data.disk.total / 1024 / 1024 / 1024).toFixed(1);
                domElements.diskDetail.textContent = `${usedGB} GB / ${totalGB} GB`;
            }
        }
        
        // Update uptime if available
        if (data.uptime && data.uptime.uptime_formatted && domElements.uptimeValue) {
            domElements.uptimeValue.textContent = data.uptime.uptime_formatted;
        }
    }
    
    // Function to update progress bar colors based on values
    function updateProgressBars() {
        const cpuProgress = document.getElementById('cpu-progress');
        const memoryProgress = document.getElementById('memory-progress');
        const diskProgress = document.getElementById('disk-progress');
        
        // Get current values
        const cpuValue = parseInt(cpuProgress.style.width) || 0;
        const memoryValue = parseInt(memoryProgress.style.width) || 0;
        const diskValue = parseInt(diskProgress.style.width) || 0;
        
        // Set colors based on values
        if (cpuValue < 50) {
            cpuProgress.style.backgroundColor = 'var(--green)';
        } else if (cpuValue < 80) {
            cpuProgress.style.backgroundColor = 'var(--yellow)';
        } else {
            cpuProgress.style.backgroundColor = 'var(--red)';
        }
        
        if (memoryValue < 50) {
            memoryProgress.style.backgroundColor = 'var(--green)';
        } else if (memoryValue < 80) {
            memoryProgress.style.backgroundColor = 'var(--yellow)';
        } else {
            memoryProgress.style.backgroundColor = 'var(--red)';
        }
        
        if (diskValue < 50) {
            diskProgress.style.backgroundColor = 'var(--green)';
        } else if (diskValue < 80) {
            diskProgress.style.backgroundColor = 'var(--yellow)';
        } else {
            diskProgress.style.backgroundColor = 'var(--red)';
        }
    }
    
    // Cache DOM elements for console status
    let consoleStatusElement = null;
    
    // Console Stream module
    const ConsoleStream = {
        // Initialize the console stream
        init() {
            this.connectToConsoleStream();
        },
        
        // Connect to the console stream
        connectToConsoleStream() {
            // Cache console status element
            if (!consoleStatusElement) {
                consoleStatusElement = document.getElementById('console-status');
            }
            
            // Close any existing connection
            if (consoleEventSource) {
                consoleEventSource.close();
                consoleEventSource = null;
            }
            
            // Update status to connecting
            if (consoleStatusElement) {
                consoleStatusElement.textContent = 'Connecting...';
                consoleStatusElement.className = 'badge badge-warning';
            }
            
            // Connect to the SSE endpoint
            try {
                consoleEventSource = new EventSource('/console-stream');
                
                // Handle connection open
                consoleEventSource.onopen = function() {
                    // Reset reconnect attempts on successful connection
                    reconnectAttempts = 0;
                    
                    if (consoleStatusElement) {
                        consoleStatusElement.textContent = 'Connected';
                        consoleStatusElement.className = 'badge badge-success';
                    }
                    appendToConsole("Connected to console stream", "info");
                };
            
            // Handle messages with batching for better performance
            let messageQueue = [];
            let processingQueue = false;
            
            consoleEventSource.addEventListener('message', function(event) {
                try {
                    const data = JSON.parse(event.data);
                    
                    // Check if this is a restart message
                    if (data.message && (
                        data.message.includes("restart") ||
                        data.message.includes("Restart") ||
                        data.message.includes("restarting") ||
                        data.message.includes("Restarting")
                    )) {
                        // Mark restart as detected
                        restartDetected = true;
                        
                        // Add a more informative message to the queue
                        messageQueue.push({
                            message: data.message,
                            type: data.is_error ? "error" : "info"
                        });
                        
                        // Add our own message about waiting for the application
                        messageQueue.push({
                            message: "APPLICATION IS RESTARTING. Please wait while the system comes back online. This process can take up to a minute...",
                            type: "warning"
                        });
                        
                        // Add a more visible notification at the top of the console
                        const restartNotification = document.createElement('div');
                        restartNotification.id = 'restart-notification';
                        restartNotification.className = 'alert alert-warning text-center';
                        restartNotification.style.position = 'sticky';
                        restartNotification.style.top = '0';
                        restartNotification.style.zIndex = '100';
                        restartNotification.style.marginBottom = '10px';
                        restartNotification.innerHTML = '<strong>System Restart in Progress</strong><br>The application is restarting. Please wait while the system comes back online. This process can take up to a minute.';
                        
                        // Add to the top of the console output
                        const consoleOutput = document.getElementById('console-output');
                        if (consoleOutput && !document.getElementById('restart-notification')) {
                            consoleOutput.insertBefore(restartNotification, consoleOutput.firstChild);
                        }
                        
                        // Start checking for application availability
                        startAvailabilityCheck();
                    } else {
                        // Regular message, add to queue
                        messageQueue.push({
                            message: data.message,
                            type: data.is_error ? "error" : "info"
                        });
                    }
                    
                    // Process queue if not already processing
                    if (!processingQueue) {
                        processMessageQueue();
                    }
                } catch (e) {
                    appendToConsole("Error parsing message: " + e.message, "error");
                }
            });
            
            // Function to process message queue with requestAnimationFrame for better UI performance
            function processMessageQueue() {
                processingQueue = true;
                
                requestAnimationFrame(function() {
                    // Process up to 20 messages at a time (increased from 10)
                    const messagesToProcess = messageQueue.splice(0, 20);
                    
                    if (messagesToProcess.length > 0) {
                        // Add messages to console
                        messagesToProcess.forEach(msg => {
                            appendToConsole(msg.message, msg.type);
                        });
                        
                        // If more messages in queue, continue processing
                        if (messageQueue.length > 0) {
                            processMessageQueue();
                        } else {
                            processingQueue = false;
                        }
                    } else {
                        processingQueue = false;
                    }
                });
            }
        } catch (e) {
            appendToConsole("Failed to connect to console stream: " + e.message, "error");
            if (consoleStatusElement) {
                consoleStatusElement.textContent = 'Connection Failed';
                consoleStatusElement.className = 'badge badge-danger';
            }
            scheduleReconnect();
        }
        
        // Handle errors with improved error handling
        consoleEventSource.addEventListener('error', function(event) {
            if (event.data) {
                try {
                    const data = JSON.parse(event.data);
                    appendToConsole(data.message, "error");
                } catch (e) {
                    // Silently ignore parsing errors
                }
            }
        });
        
        // Handle connection errors with cached DOM element and exponential backoff
        consoleEventSource.onerror = function(event) {
            // Check if the connection was never established
            if (consoleEventSource.readyState === 0) {
                appendToConsole('Failed to connect to console stream. Will retry automatically.', "error");
                if (consoleStatusElement) {
                    consoleStatusElement.textContent = 'Connection Failed';
                    consoleStatusElement.className = 'badge badge-danger';
                }
                scheduleReconnect();
            }
            // Check if the connection was lost after being established
            else if (consoleEventSource.readyState === 2) {
                // If we detect a message about restarting, mark as restart detected
                if (!restartDetected) {
                    appendToConsole('Connection to console stream lost. This may be due to application restart.', "warning");
                    appendToConsole('Waiting for application to become available again...', "info");
                    restartDetected = true;
                    
                    // Start checking for application availability
                    startAvailabilityCheck();
                } else {
                    appendToConsole('Connection to console stream lost. Attempting to reconnect...', "warning");
                }
                
                if (consoleStatusElement) {
                    consoleStatusElement.textContent = 'Disconnected';
                    consoleStatusElement.className = 'badge badge-warning';
                }
                scheduleReconnect();
            }
        };
    }
    
    // Function to schedule reconnection with exponential backoff
    function scheduleReconnect() {
        reconnectAttempts++;
        
        // If we've detected a restart, use a fixed interval instead of exponential backoff
        if (restartDetected) {
            const delay = 10000; // Fixed 10 second delay during restart
            
            if (reconnectAttempts <= MAX_RECONNECT_ATTEMPTS) {
                appendToConsole(`Checking if application is available... (attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`, "info");
                setTimeout(connectToConsoleStream, delay);
            } else {
                appendToConsole("Maximum reconnection attempts reached. Please refresh the page manually.", "error");
                stopAvailabilityCheck();
            }
        } else {
            // Normal exponential backoff for non-restart connection issues
            const delay = Math.min(1000 * Math.pow(2, reconnectAttempts - 1), MAX_RECONNECT_DELAY);
            appendToConsole(`Reconnecting in ${delay/1000} seconds (attempt ${reconnectAttempts})...`, "info");
            setTimeout(connectToConsoleStream, delay);
        }
    }
    
    // Function to start checking for application availability
    function startAvailabilityCheck() {
        if (availabilityCheckInterval) {
            clearInterval(availabilityCheckInterval);
        }
        
        // Check server availability every 5 seconds
        availabilityCheckInterval = setInterval(checkServerAvailability, 5000);
    }
    
    // Function to stop checking for application availability
    function stopAvailabilityCheck() {
        if (availabilityCheckInterval) {
            clearInterval(availabilityCheckInterval);
            availabilityCheckInterval = null;
        }
        restartDetected = false;
    }
    
    // Function to check if the server is available
    function checkServerAvailability() {
        fetch('/api/system-info', {
            method: 'GET',
            headers: { 'Cache-Control': 'no-cache' },
            // Add a timestamp to prevent caching
            cache: 'no-store'
        })
        .then(response => {
            if (response.ok) {
                // Server is available again
                appendToConsole("Application is back online! Reconnecting to console stream...", "info");
                stopAvailabilityCheck();
                connectToConsoleStream();
                
                // Reset reconnect attempts
                reconnectAttempts = 0;
                
                // Update system info
                refreshSystemInfo();
                
                // Remove restart notification if it exists
                const restartNotification = document.getElementById('restart-notification');
                if (restartNotification) {
                    restartNotification.remove();
                }
            }
        })
        .catch(error => {
            // Server still unavailable, will try again on next interval
            console.log("Server still unavailable:", error);
        });
    }
    
    // Cache DOM elements for console output
    let consoleOutputElement = null;
    
    // Cache icons for message types
    const messageIcons = {
        'error': '<i class="fas fa-exclamation-triangle"></i> ',
        'warning': '<i class="fas fa-exclamation-circle"></i> ',
        'info': '<i class="fas fa-info-circle"></i> '
    };
    
    // Limit the number of messages to prevent memory issues
    const MAX_MESSAGES = 500; // Reduced from 1000 to 500 to improve performance
    
    function appendToConsole(message, type) {
        // Get console output element if not cached
        if (!consoleOutputElement) {
            consoleOutputElement = document.getElementById('console-output');
        }
        
        // Store message in our array with a more efficient timestamp
        const now = new Date();
        const timestamp = now.toISOString().replace('T', ' ').substr(0, 19);
        
        const messageObj = {
            message: message,
            type: type,
            timestamp: timestamp
        };
        
        // Add to messages array with limit check - use unshift for better performance when trimming
        // This adds new messages to the beginning of the array, making it faster to trim old messages
        allMessages.unshift(messageObj);
        
        // Trim messages array if it gets too large
        if (allMessages.length > MAX_MESSAGES) {
            allMessages.length = MAX_MESSAGES; // More efficient than slice
        }
        
        // Check if this message should be displayed based on current filter
        if (shouldDisplayMessage(messageObj)) {
            addMessageToDOM(messageObj);
        }
    }
    
    function addMessageToDOM(messageObj) {
        // Get console output element if not cached
        if (!consoleOutputElement) {
            consoleOutputElement = document.getElementById('console-output');
        }
        
        // Create message element
        const messageElement = document.createElement('div');
        messageElement.className = `console-message ${messageObj.type}`;
        
        // Add timestamp
        const timestampSpan = document.createElement('span');
        timestampSpan.className = 'timestamp';
        timestampSpan.textContent = messageObj.timestamp;
        messageElement.appendChild(timestampSpan);
        
        // Add message with appropriate icon
        const icon = messageIcons[messageObj.type] || '';
        
        const messageContent = document.createElement('span');
        messageContent.className = 'message-content';
        
        // Highlight search term if present
        if (searchTerm && messageObj.message.toLowerCase().includes(searchTerm.toLowerCase())) {
            const regex = new RegExp(`(${searchTerm})`, 'gi');
            messageContent.innerHTML = icon + messageObj.message.replace(regex, '<span class="highlight">$1</span>');
        } else {
            messageContent.innerHTML = icon + messageObj.message;
        }
        
        messageElement.appendChild(messageContent);
        
        // Append to console output
        consoleOutputElement.appendChild(messageElement);
        
        // Limit the number of DOM elements to prevent browser slowdown
        if (consoleOutputElement.children.length > MAX_MESSAGES) {
            // Remove oldest messages
            while (consoleOutputElement.children.length > MAX_MESSAGES) {
                consoleOutputElement.removeChild(consoleOutputElement.firstChild);
            }
        }
        
        // Auto-scroll to bottom if enabled
        if (autoScroll) {
            // Use requestAnimationFrame for smoother scrolling
            requestAnimationFrame(scrollToBottom);
        }
    }
    
    function scrollToBottom() {
        // Use cached element if available
        if (!consoleOutputElement) {
            consoleOutputElement = document.getElementById('console-output');
        }
        
        // Use scrollTop for better performance
        consoleOutputElement.scrollTop = consoleOutputElement.scrollHeight;
    }
    
    function clearConsole() {
        // Use cached element if available
        if (!consoleOutputElement) {
            consoleOutputElement = document.getElementById('console-output');
        }
        
        // Clear console with a single operation
        consoleOutputElement.innerHTML = '<div class="console-message text-muted">Console cleared</div>';
        
        // Reset messages array
        allMessages = [];
    }
    
    // Function to refresh the console display based on current filter and search
    function refreshConsoleDisplay() {
        // Use cached element if available
        if (!consoleOutputElement) {
            consoleOutputElement = document.getElementById('console-output');
        }
        
        // Clear current display - use a more efficient method
        while (consoleOutputElement.firstChild) {
            consoleOutputElement.removeChild(consoleOutputElement.firstChild);
        }
        
        // Re-add messages that match the filter and search
        // Use a fragment for better performance
        const fragment = document.createDocumentFragment();
        
        // Count how many messages we're displaying
        let displayCount = 0;
        
        // Since we changed allMessages to add at the beginning (unshift),
        // we can now process in forward order which is more efficient
        for (let i = 0; i < allMessages.length && displayCount < MAX_MESSAGES; i++) {
            if (shouldDisplayMessage(allMessages[i])) {
                // Create message element directly in the fragment
                const messageObj = allMessages[i];
                const messageElement = document.createElement('div');
                messageElement.className = `console-message ${messageObj.type}`;
                
                // Add timestamp
                const timestampSpan = document.createElement('span');
                timestampSpan.className = 'timestamp';
                timestampSpan.textContent = messageObj.timestamp;
                messageElement.appendChild(timestampSpan);
                
                // Add message with appropriate icon
                const icon = messageIcons[messageObj.type] || '';
                
                const messageContent = document.createElement('span');
                messageContent.className = 'message-content';
                
                // Highlight search term if present - use a safer regex approach
                if (searchTerm && messageObj.message.toLowerCase().includes(searchTerm.toLowerCase())) {
                    try {
                        // Escape special regex characters to prevent regex errors
                        const escapedSearchTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                        const regex = new RegExp(`(${escapedSearchTerm})`, 'gi');
                        messageContent.innerHTML = icon + messageObj.message.replace(regex, '<span class="highlight">$1</span>');
                    } catch (e) {
                        // Fallback if regex fails
                        messageContent.innerHTML = icon + messageObj.message;
                    }
                } else {
                    messageContent.innerHTML = icon + messageObj.message;
                }
                
                messageElement.appendChild(messageContent);
                // Add to fragment in chronological order (oldest first)
                fragment.appendChild(messageElement);
                displayCount++;
            }
        }
        
        // Add all elements at once
        consoleOutputElement.appendChild(fragment);
        
        // Auto-scroll to bottom if enabled
        if (autoScroll) {
            requestAnimationFrame(scrollToBottom);
        }
    }
    
    function filterLogs() {
        currentFilter = document.getElementById('log-level-filter').value;
        refreshConsoleDisplay();
    }
    
    function searchLogs() {
        searchTerm = document.getElementById('console-search').value.trim();
        refreshConsoleDisplay();
    }
    
    function shouldDisplayMessage(msg) {
        // Check if message passes the current filter
        if (currentFilter !== 'all' && msg.type !== currentFilter) {
            return false;
        }
        
        // Check if message contains search term
        if (searchTerm && !msg.message.toLowerCase().includes(searchTerm.toLowerCase())) {
            return false;
        }
        
        return true;
    }
    
    function exportLogs() {
        // Create a formatted string of all logs
        let logText = "Cybex Pulse Console Logs - Exported " + new Date().toISOString() + "\n\n";
        
        allMessages.forEach(msg => {
            logText += `[${msg.timestamp}] [${msg.type.toUpperCase()}] ${msg.message}\n`;
        });
        
        // Create a blob and download link
        const blob = new Blob([logText], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = 'cybex-pulse-logs-' + new Date().toISOString().replace(/:/g, '-') + '.txt';
        document.body.appendChild(a);
        a.click();
        
        // Clean up
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
    }
    
    // Clean up event source when leaving the page
    window.addEventListener('beforeunload', function() {
        if (consoleEventSource) {
            consoleEventSource.close();
        }
    });
    
    // Initialize the application when the DOM is loaded
    document.addEventListener('DOMContentLoaded', init);
    
    // Return public API
    return {
        init,
        SystemInfo,
        refreshConsoleDisplay,
        clearConsole,
        exportLogs
    };
})();
</script>
{% endblock %}

{% block additional_scripts %}
<script>
// Simple script to connect to the console stream
document.addEventListener('DOMContentLoaded', function() {
    // Wait a moment for the page to fully load
    setTimeout(function() {
        // Get the console output element
        const consoleOutput = document.getElementById('console-output');
        const consoleStatus = document.getElementById('console-status');
        
        // Update status to connecting
        if (consoleStatus) {
            consoleStatus.textContent = 'Connecting...';
            consoleStatus.className = 'badge badge-warning';
        }
        
        // Clear the "Connecting to console stream..." message
        if (consoleOutput) {
            consoleOutput.innerHTML = '';
        }
        
        // Connect to the SSE endpoint
        try {
            const eventSource = new EventSource('/console-stream');
            
            // Handle connection open
            eventSource.onopen = function() {
                if (consoleStatus) {
                    consoleStatus.textContent = 'Connected';
                    consoleStatus.className = 'badge badge-success';
                }
                
                // Add a connected message
                if (consoleOutput) {
                    const messageElement = document.createElement('div');
                    messageElement.className = 'console-message info';
                    messageElement.innerHTML = '<span class="timestamp">' + new Date().toISOString().replace('T', ' ').substr(0, 19) + '</span><i class="fas fa-info-circle"></i> Connected to console stream';
                    consoleOutput.appendChild(messageElement);
                    consoleOutput.scrollTop = consoleOutput.scrollHeight;
                }
            };
            
            // Handle messages
            eventSource.addEventListener('message', function(event) {
                try {
                    const data = JSON.parse(event.data);
                    
                    if (consoleOutput) {
                        const messageElement = document.createElement('div');
                        messageElement.className = 'console-message ' + (data.type || 'info');
                        
                        // Add timestamp
                        const timestampSpan = document.createElement('span');
                        timestampSpan.className = 'timestamp';
                        timestampSpan.textContent = data.timestamp || new Date().toISOString().replace('T', ' ').substr(0, 19);
                        messageElement.appendChild(timestampSpan);
                        
                        // Add message with appropriate icon
                        let icon = '';
                        if (data.type === 'error') {
                            icon = '<i class="fas fa-exclamation-triangle"></i> ';
                        } else if (data.type === 'warning') {
                            icon = '<i class="fas fa-exclamation-circle"></i> ';
                        } else {
                            icon = '<i class="fas fa-info-circle"></i> ';
                        }
                        
                        const messageContent = document.createElement('span');
                        messageContent.className = 'message-content';
                        messageContent.innerHTML = icon + data.message;
                        messageElement.appendChild(messageContent);
                        
                        // Add to console output
                        consoleOutput.appendChild(messageElement);
                        
                        // Auto-scroll to bottom
                        consoleOutput.scrollTop = consoleOutput.scrollHeight;
                    }
                } catch (e) {
                    console.error('Error parsing message:', e);
                }
            });
            
            // Handle errors
            eventSource.onerror = function() {
                if (consoleStatus) {
                    consoleStatus.textContent = 'Disconnected';
                    consoleStatus.className = 'badge badge-danger';
                }
                
                // Add an error message
                if (consoleOutput) {
                    const messageElement = document.createElement('div');
                    messageElement.className = 'console-message error';
                    messageElement.innerHTML = '<span class="timestamp">' + new Date().toISOString().replace('T', ' ').substr(0, 19) + '</span><i class="fas fa-exclamation-triangle"></i> Connection to console stream lost. Refresh the page to reconnect.';
                    consoleOutput.appendChild(messageElement);
                    consoleOutput.scrollTop = consoleOutput.scrollHeight;
                }
                
                // Close the connection
                eventSource.close();
            };
            
            // Clean up when leaving the page
            window.addEventListener('beforeunload', function() {
                eventSource.close();
            });
        } catch (e) {
            console.error('Error connecting to console stream:', e);
            
            // Add an error message
            if (consoleOutput) {
                const messageElement = document.createElement('div');
                messageElement.className = 'console-message error';
                messageElement.innerHTML = '<span class="timestamp">' + new Date().toISOString().replace('T', ' ').substr(0, 19) + '</span><i class="fas fa-exclamation-triangle"></i> Failed to connect to console stream: ' + e.message;
                consoleOutput.appendChild(messageElement);
            }
        }
    }, 500); // Wait 500ms for the page to fully load
});
</script>
{% endblock %}