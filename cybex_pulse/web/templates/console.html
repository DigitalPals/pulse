{% extends "base.html" %}

{% block title %}Console - Cybex Pulse{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <!-- System Information Cards -->
            <div class="card">
                <div class="card-header">
                    <h3>System Console</h3>
                    <span id="last-updated">Last updated: <span id="update-time-text" class="update-time-text">Just now</span></span>
                </div>
                <div class="grid">
                    <!-- CPU Card -->
                    <div class="stat-card">
                        <div class="stat-icon"><i class="fas fa-microchip"></i></div>
                        <h4>CPU load</h4>
                        <div class="stat-value" id="cpu-usage">{{ system_info.cpu.normalized_load_avg[0]|int if system_info.cpu.normalized_load_avg else system_info.cpu.percent|int }}%</div>
                        <div class="progress-container">
                            <div class="progress-bar" id="cpu-progress" style="width: {{ system_info.cpu.normalized_load_avg[0]|int if system_info.cpu.normalized_load_avg else system_info.cpu.percent|int }}%"></div>
                        </div>
                        <div class="stat-detail">
                            <small>{{ system_info.cpu.count }} cores | {{ system_info.cpu.model }}</small>
                        </div>
                    </div>
                    
                    <!-- Memory Card -->
                    <div class="stat-card">
                        <div class="stat-icon"><i class="fas fa-memory"></i></div>
                        <h4>Memory usage</h4>
                        <div class="stat-value" id="memory-usage">{{ system_info.memory.percent|int }}%</div>
                        <div class="progress-container">
                            <div class="progress-bar" id="memory-progress" style="width: {{ system_info.memory.percent|int }}%"></div>
                        </div>
                        <div class="stat-detail">
                            <small>{{ (system_info.memory.used / 1024 / 1024 / 1024)|round(1) }} GB / {{ (system_info.memory.total / 1024 / 1024 / 1024)|round(1) }} GB</small>
                        </div>
                    </div>
                    
                    <!-- Disk Card -->
                    <div class="stat-card">
                        <div class="stat-icon"><i class="fas fa-hdd"></i></div>
                        <h4>Disk usage</h4>
                        <div class="stat-value" id="disk-usage">{{ system_info.disk.percent|int }}%</div>
                        <div class="progress-container">
                            <div class="progress-bar" id="disk-progress" style="width: {{ system_info.disk.percent|int }}%"></div>
                        </div>
                        <div class="stat-detail">
                            <small>{{ (system_info.disk.used / 1024 / 1024 / 1024)|round(1) if system_info.disk.used else 0 }} GB / {{ (system_info.disk.total / 1024 / 1024 / 1024)|round(1) if system_info.disk.total else 0 }} GB</small>
                        </div>
                    </div>
                </div>
            </div>
            </div>
            
            <!-- Console Output Card -->
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <div class="d-flex align-items-center">
                        <h5 class="mb-0 mr-3">Console Output</h5>
                        <span id="console-status" class="badge badge-primary ml-2">Connected</span>
                    </div>
                    <div class="console-controls">
                        <div class="console-filter">
                            <select id="log-level-filter" class="form-control form-control-sm">
                                <option value="all">All logs</option>
                                <option value="error">Errors only</option>
                                <option value="warning">Warnings only</option>
                                <option value="info">Info only</option>
                            </select>
                        </div>
                        <div class="console-search">
                            <input type="text" id="console-search" class="form-control form-control-sm" placeholder="Search logs...">
                            <button id="search-btn" class="btn btn-sm btn-secondary">
                                <i class="fas fa-search"></i>
                            </button>
                        </div>
                        <div class="autoscroll-toggle">
                            <label class="toggle-switch">
                                <input type="checkbox" id="autoscroll-toggle" checked>
                                <span class="toggle-slider"></span>
                            </label>
                            <span class="toggle-label">Auto-scroll</span>
                        </div>
                    </div>
                </div>
                <div class="card-body">
                    <div id="console-output" class="bg-dark text-light p-3 rounded console-container">
                        <div class="text-muted console-message">Connecting to console stream...</div>
                    </div>
                </div>
                <div class="card-footer">
                    <div class="d-flex justify-content-between">
                        <div>
                            <button id="clear-btn" class="btn btn-secondary">
                                <i class="fas fa-trash"></i> Clear Console
                            </button>
                            <button id="export-btn" class="btn btn-secondary ml-2">
                                <i class="fas fa-download"></i> Export Logs
                            </button>
                        </div>
                        <button id="back-btn" class="btn btn-secondary" onclick="window.location.href='/'">
                            <i class="fas fa-arrow-left"></i> Back to Dashboard
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Custom styles for console page -->
<style>
    .card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    #last-updated {
        font-size: 0.9rem;
        color: var(--text-muted);
    }
    
    .update-time-text {
        font-weight: 500;
    }
    
    .update-time-normal {
        color: var(--text-color);
    }
    
    .update-time-warning {
        color: var(--yellow);
    }
    
    .progress-container {
        width: 100%;
        height: 8px;
        background-color: var(--border-color);
        border-radius: 4px;
        margin: 10px 0;
        overflow: hidden;
    }
    
    .progress-bar {
        height: 100%;
        border-radius: 4px;
        transition: width 0.5s ease-in-out;
    }
    
    /* Use solid colors instead of gradients for better performance */
    #cpu-progress {
        background-color: var(--green);
    }
    
    #memory-progress {
        background-color: var(--green);
    }
    
    #disk-progress {
        background-color: var(--green);
    }
    
    .console-container {
        height: 500px;
        overflow-y: auto;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        line-height: 1.5;
        padding: 15px;
        position: relative;
    }
    
    .console-message {
        padding: 3px 5px;
        border-radius: 2px;
        margin-bottom: 2px;
        position: relative;
        white-space: pre-wrap;
        word-break: break-word;
    }
    
    .console-message:hover {
        background-color: rgba(255, 255, 255, 0.05);
    }
    
    .console-message.error {
        color: var(--red);
        background-color: rgba(217, 58, 58, 0.1);
        border-left: 3px solid var(--red);
        padding-left: 8px;
    }
    
    .console-message.warning {
        color: var(--yellow);
        background-color: rgba(255, 193, 7, 0.1);
        border-left: 3px solid var(--yellow);
        padding-left: 8px;
    }
    
    .console-message.info {
        color: var(--highlight-blue);
        border-left: 3px solid var(--highlight-blue);
        padding-left: 8px;
    }
    
    .console-message .timestamp {
        color: var(--text-muted);
        font-size: 0.85em;
        margin-right: 8px;
    }
    
    .console-controls {
        display: flex;
        align-items: center;
        gap: 15px;
    }
    
    .console-search {
        display: flex;
        align-items: center;
    }
    
    .console-search input {
        width: 200px;
        margin-right: 5px;
    }
    
    .autoscroll-toggle {
        display: flex;
        align-items: center;
    }
    
    .autoscroll-toggle .toggle-switch {
        margin-right: 5px;
    }
    .highlight {
        background-color: rgba(255, 193, 7, 0.3);
        color: white;
        border-radius: 2px;
        padding: 0 2px;
    }
    
    /* Restart notification styling */
    #restart-notification {
        position: sticky;
        top: 0;
        z-index: 100;
        margin-bottom: 10px;
        padding: 10px;
        border-radius: 4px;
        background-color: rgba(255, 193, 7, 0.2);
        border: 1px solid var(--yellow);
    }
    
    
    @media (max-width: 768px) {
        .console-controls {
            flex-direction: column;
            align-items: flex-start;
            gap: 10px;
            margin-top: 10px;
        }
        
        .console-search input {
            width: 150px;
        }
        
        .card-header {
            flex-direction: column;
            align-items: flex-start;
        }
        
        .console-filter, .console-search {
            width: 100%;
        }
    }
</style>
{% endblock %}

{% block scripts %}
<script src="/static/js/console-stream.js"></script>
<script>
// Console module - Refactored for better organization and performance
document.addEventListener('DOMContentLoaded', function() {
    // Configuration constants
    const CONFIG = {
        MAX_MESSAGES: 500,
        SYSTEM_INFO_REFRESH_INTERVAL: 10000,
        LAST_UPDATED_REFRESH_INTERVAL: 30000,
        AVAILABILITY_CHECK_INTERVAL: 5000,
        MAX_RECONNECT_DELAY: 30000,
        MAX_RECONNECT_ATTEMPTS: 30,
        INITIAL_STREAM_DELAY: 500
    };
    
    // State variables
    let consoleEventSource = null;
    let autoScroll = true;
    let allMessages = [];
    let currentFilter = 'all';
    let searchTerm = '';
    let streamInitialized = false;
    let restartDetected = false;
    let availabilityCheckInterval = null;
    let reconnectAttempts = 0;
    let consoleStatusElement = null;
    let consoleOutputElement = null;

    // DOM element cache
    const elements = {
        // System info elements
        cpuUsage: document.getElementById('cpu-usage'),
        cpuProgress: document.getElementById('cpu-progress'),
        cpuDetail: document.querySelector('.stat-card:first-child .stat-detail small'),
        memoryUsage: document.getElementById('memory-usage'),
        memoryProgress: document.getElementById('memory-progress'),
        memoryDetail: document.querySelector('.stat-card:nth-child(2) .stat-detail small'),
        diskUsage: document.getElementById('disk-usage'),
        diskProgress: document.getElementById('disk-progress'),
        diskDetail: document.querySelector('.stat-card:nth-child(3) .stat-detail small'),
        
        // Console elements
        consoleOutput: document.getElementById('console-output'),
        consoleStatus: document.getElementById('console-status'),
        logLevelFilter: document.getElementById('log-level-filter'),
        consoleSearch: document.getElementById('console-search'),
        searchBtn: document.getElementById('search-btn'),
        autoscrollToggle: document.getElementById('autoscroll-toggle'),
        clearBtn: document.getElementById('clear-btn'),
        exportBtn: document.getElementById('export-btn'),
        updateTimeText: document.getElementById('update-time-text')
    };
    
    // Cache console elements for easier access
    consoleOutputElement = elements.consoleOutput;
    consoleStatusElement = elements.consoleStatus;
    
    // Initialize the application
    function init() {
        // Set up event listeners
        setupEventListeners();
        
        // Initialize system info
        refreshSystemInfo();
        setInterval(refreshSystemInfo, CONFIG.SYSTEM_INFO_REFRESH_INTERVAL);
        
        // Initialize last updated time
        updateLastUpdated();
        setInterval(updateLastUpdated, CONFIG.LAST_UPDATED_REFRESH_INTERVAL);
        
        // Initialize console stream with a slight delay
        setTimeout(() => {
            // Connect to the console stream
            connectToConsoleStream();
            streamInitialized = true;
            scrollToBottom();
        }, CONFIG.INITIAL_STREAM_DELAY);
    }
    
    // Set up event listeners for controls
    function setupEventListeners() {
        // Log level filter
        elements.logLevelFilter.addEventListener('change', () => {
            currentFilter = elements.logLevelFilter.value;
            refreshConsoleDisplay();
        });
        
        // Search input
        elements.consoleSearch.addEventListener('input', () => {
            searchTerm = elements.consoleSearch.value.trim();
            refreshConsoleDisplay();
        });
        
        // Search button
        elements.searchBtn.addEventListener('click', () => {
            searchTerm = elements.consoleSearch.value.trim();
            refreshConsoleDisplay();
        });
        
        // Search on enter key
        elements.consoleSearch.addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                searchTerm = elements.consoleSearch.value.trim();
                refreshConsoleDisplay();
            }
        });
        
        // Auto-scroll toggle
        elements.autoscrollToggle.addEventListener('change', (e) => {
            autoScroll = e.target.checked;
            if (autoScroll) {
                scrollToBottom();
            }
        });
        
        // Clear console button
        elements.clearBtn.addEventListener('click', clearConsole);
        
        // Export logs button
        elements.exportBtn.addEventListener('click', exportLogs);
        
        // Console scrolling
        setupScrollHandling();
    }
    
    function setupScrollHandling() {
        if (!consoleOutputElement) return;
        
        // Variables to track user scrolling vs. content additions
        let lastScrollHeight = 0;
        let userScrolledUp = false;
        let scrollTimeout = null;
        
        // Initialize the last scroll height
        setTimeout(() => {
            lastScrollHeight = consoleOutputElement.scrollHeight;
        }, 500);
        
        consoleOutputElement.addEventListener('scroll', function() {
            // Clear any pending scroll timeout
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
            }
            
            // Calculate how far from the bottom we are
            const scrollBottom = consoleOutputElement.scrollHeight - consoleOutputElement.scrollTop - consoleOutputElement.clientHeight;
            
            // If the scroll height hasn't changed, this is a user-initiated scroll
            if (consoleOutputElement.scrollHeight === lastScrollHeight) {
                // User scrolled up if we're more than 50px from bottom
                userScrolledUp = scrollBottom > 50;
                
                // If user scrolled up, disable auto-scroll
                if (userScrolledUp && autoScroll) {
                    elements.autoscrollToggle.checked = false;
                    autoScroll = false;
                }
                
                // If user scrolled to bottom, re-enable auto-scroll if toggle is checked
                if (scrollBottom < 10 && !autoScroll && elements.autoscrollToggle.checked) {
                    autoScroll = true;
                }
            } else {
                // Content was added, update the last scroll height
                lastScrollHeight = consoleOutputElement.scrollHeight;
                
                // If auto-scroll is enabled, scroll to bottom after a short delay
                if (autoScroll) {
                    scrollTimeout = setTimeout(scrollToBottom, 50);
                }
            }
        });
    }
    
    // Refresh system information from API
    let refreshInProgress = false;
    function refreshSystemInfo() {
        if (refreshInProgress) return;
        
        refreshInProgress = true;
        
        // Fetch data from separate endpoints for better performance
        Promise.all([
            fetch('/api/system-info/cpu').then(response => response.json()),
            fetch('/api/system-info/memory').then(response => response.json()),
            fetch('/api/system-info/disk').then(response => response.json())
        ])
        .then(([cpuData, memoryData, diskData]) => {
            const data = { cpu: cpuData, memory: memoryData, disk: diskData };
            updateSystemInfoCards(data);
            updateProgressBars();
            updateLastUpdated();
            refreshInProgress = false;
        })
        .catch(error => {
            console.error('Error fetching system info:', error);
            refreshInProgress = false;
            setTimeout(refreshSystemInfo, 5000);
        });
    }
    
    // Update the "last updated" time display
    function updateLastUpdated() {
        const updateTimeElement = elements.updateTimeText;
        if (!updateTimeElement) return;
        
        const now = new Date();
        const lastUpdate = window.lastUpdateTime || now;
        window.lastUpdateTime = now;
        
        const diffInSeconds = Math.floor((now - lastUpdate) / 1000);
        
        let text = 'Just now';
        let className = 'update-time-normal';
        
        if (diffInSeconds < 60) {
            text = 'Just now';
        } else if (diffInSeconds < 300) {
            text = 'Less than 5 minutes ago';
        } else {
            text = 'Over 5 minutes ago';
            className = 'update-time-warning';
        }
        
        updateTimeElement.textContent = text;
        updateTimeElement.className = 'update-time-text ' + className;
    }
    
    // Update system info cards with new data
    function updateSystemInfoCards(data) {
        // Update CPU info
        if (data.cpu) {
            const cpuValue = data.cpu.normalized_load_avg ?
                data.cpu.normalized_load_avg[0] : data.cpu.percent;
            const cpuRounded = Math.round(cpuValue);
            
            if (elements.cpuUsage) elements.cpuUsage.textContent = cpuRounded + '%';
            if (elements.cpuProgress) elements.cpuProgress.style.width = cpuRounded + '%';
            
            if (elements.cpuDetail && data.cpu.count && data.cpu.model) {
                elements.cpuDetail.textContent = `${data.cpu.count} cores | ${data.cpu.model}`;
            }
        }
        
        // Update Memory info
        if (data.memory) {
            const memRounded = Math.round(data.memory.percent);
            
            if (elements.memoryUsage) elements.memoryUsage.textContent = memRounded + '%';
            if (elements.memoryProgress) elements.memoryProgress.style.width = memRounded + '%';
            
            if (elements.memoryDetail && data.memory.used && data.memory.total) {
                const usedGB = (data.memory.used / 1024 / 1024 / 1024).toFixed(1);
                const totalGB = (data.memory.total / 1024 / 1024 / 1024).toFixed(1);
                elements.memoryDetail.textContent = `${usedGB} GB / ${totalGB} GB`;
            }
        }
        
        // Update Disk info
        if (data.disk) {
            const diskRounded = Math.round(data.disk.percent);
            
            if (elements.diskUsage) elements.diskUsage.textContent = diskRounded + '%';
            if (elements.diskProgress) elements.diskProgress.style.width = diskRounded + '%';
            
            if (elements.diskDetail && data.disk.used && data.disk.total) {
                const usedGB = (data.disk.used / 1024 / 1024 / 1024).toFixed(1);
                const totalGB = (data.disk.total / 1024 / 1024 / 1024).toFixed(1);
                elements.diskDetail.textContent = `${usedGB} GB / ${totalGB} GB`;
            }
        }
    }
    
    // Update progress bar colors based on values
    function updateProgressBars() {
        const updateBarColor = (bar, value) => {
            if (!bar) return;
            
            if (value < 50) {
                bar.style.backgroundColor = 'var(--green)';
            } else if (value < 80) {
                bar.style.backgroundColor = 'var(--yellow)';
            } else {
                bar.style.backgroundColor = 'var(--red)';
            }
        };
        
        // Get current values
        const cpuValue = parseInt(elements.cpuProgress?.style.width) || 0;
        const memoryValue = parseInt(elements.memoryProgress?.style.width) || 0;
        const diskValue = parseInt(elements.diskProgress?.style.width) || 0;
        
        // Update colors
        updateBarColor(elements.cpuProgress, cpuValue);
        updateBarColor(elements.memoryProgress, memoryValue);
        updateBarColor(elements.diskProgress, diskValue);
    }
    
    // Connect to the console stream
    function connectToConsoleStream() {
        // Close any existing connection
        if (consoleEventSource) {
            consoleEventSource.close();
            consoleEventSource = null;
        }
        
        // Update status to connecting
        if (consoleStatusElement) {
            consoleStatusElement.textContent = 'Connecting...';
            consoleStatusElement.className = 'badge badge-warning';
        }
        
        // Connect to the SSE endpoint
        try {
            consoleEventSource = new EventSource('/console-stream');
            
            // Handle connection open
            consoleEventSource.onopen = function() {
                // Reset reconnect attempts on successful connection
                reconnectAttempts = 0;
                
                if (consoleStatusElement) {
                    consoleStatusElement.textContent = 'Connected';
                    consoleStatusElement.className = 'badge badge-success';
                }
                appendToConsole("Connected to console stream", "info");
            };
            
            // Handle messages with batching for better performance
            let messageQueue = [];
            let processingQueue = false;
            
            consoleEventSource.addEventListener('message', function(event) {
                try {
                    const data = JSON.parse(event.data);
                    
                    // Check if this is a restart message
                    if (data.message && (
                        data.message.includes("restart") ||
                        data.message.includes("Restart") ||
                        data.message.includes("restarting") ||
                        data.message.includes("Restarting")
                    )) {
                        // Mark restart as detected
                        restartDetected = true;
                        
                        // Add a more informative message to the queue
                        messageQueue.push({
                            message: data.message,
                            type: data.is_error ? "error" : "info"
                        });
                        
                        // Add our own message about waiting for the application
                        messageQueue.push({
                            message: "APPLICATION IS RESTARTING. Please wait while the system comes back online. This process can take up to a minute...",
                            type: "warning"
                        });
                        
                        // Add a more visible notification at the top of the console
                        const restartNotification = document.createElement('div');
                        restartNotification.id = 'restart-notification';
                        restartNotification.className = 'alert alert-warning text-center';
                        restartNotification.style.position = 'sticky';
                        restartNotification.style.top = '0';
                        restartNotification.style.zIndex = '100';
                        restartNotification.style.marginBottom = '10px';
                        restartNotification.innerHTML = '<strong>System Restart in Progress</strong><br>The application is restarting. Please wait while the system comes back online. This process can take up to a minute.';
                        
                        // Add to the top of the console output
                        if (consoleOutputElement && !document.getElementById('restart-notification')) {
                            consoleOutputElement.insertBefore(restartNotification, consoleOutputElement.firstChild);
                        }
                        
                        // Start checking for application availability
                        startAvailabilityCheck();
                    } else {
                        // Regular message, add to queue
                        messageQueue.push({
                            message: data.message,
                            type: data.is_error ? "error" : "info"
                        });
                    }
                    
                    // Process queue if not already processing
                    if (!processingQueue) {
                        processMessageQueue();
                    }
                } catch (e) {
                    appendToConsole("Error parsing message: " + e.message, "error");
                }
            });
            
            // Function to process message queue with requestAnimationFrame for better UI performance
            function processMessageQueue() {
                processingQueue = true;
                
                requestAnimationFrame(function() {
                    // Process up to 20 messages at a time
                    const messagesToProcess = messageQueue.splice(0, 20);
                    
                    if (messagesToProcess.length > 0) {
                        // Add messages to console
                        messagesToProcess.forEach(msg => {
                            appendToConsole(msg.message, msg.type);
                        });
                        
                        // If more messages in queue, continue processing
                        if (messageQueue.length > 0) {
                            processMessageQueue();
                        } else {
                            processingQueue = false;
                        }
                    } else {
                        processingQueue = false;
                    }
                });
            }
            
            // Handle errors with improved error handling
            consoleEventSource.addEventListener('error', function(event) {
                if (event.data) {
                    try {
                        const data = JSON.parse(event.data);
                        appendToConsole(data.message, "error");
                    } catch (e) {
                        // Silently ignore parsing errors
                    }
                }
            });
            
            // Handle connection errors with cached DOM element and exponential backoff
            consoleEventSource.onerror = function(event) {
                // Check if the connection was never established
                if (consoleEventSource.readyState === 0) {
                    appendToConsole('Failed to connect to console stream. Will retry automatically.', "error");
                    if (consoleStatusElement) {
                        consoleStatusElement.textContent = 'Connection Failed';
                        consoleStatusElement.className = 'badge badge-danger';
                    }
                    scheduleReconnect();
                }
                // Check if the connection was lost after being established
                else if (consoleEventSource.readyState === 2) {
                    // If we detect a message about restarting, mark as restart detected
                    if (!restartDetected) {
                        appendToConsole('Connection to console stream lost. This may be due to application restart.', "warning");
                        appendToConsole('Waiting for application to become available again...', "info");
                        restartDetected = true;
                        
                        // Start checking for application availability
                        startAvailabilityCheck();
                    } else {
                        appendToConsole('Connection to console stream lost. Attempting to reconnect...', "warning");
                    }
                    
                    if (consoleStatusElement) {
                        consoleStatusElement.textContent = 'Disconnected';
                        consoleStatusElement.className = 'badge badge-warning';
                    }
                    scheduleReconnect();
                }
            };
        } catch (e) {
            appendToConsole("Failed to connect to console stream: " + e.message, "error");
            if (consoleStatusElement) {
                consoleStatusElement.textContent = 'Connection Failed';
                consoleStatusElement.className = 'badge badge-danger';
            }
            scheduleReconnect();
        }
    }
    
    // Function to schedule reconnection with exponential backoff
    function scheduleReconnect() {
        reconnectAttempts++;
        
        // If we've detected a restart, use a fixed interval instead of exponential backoff
        if (restartDetected) {
            const delay = 10000; // Fixed 10 second delay during restart
            
            if (reconnectAttempts <= CONFIG.MAX_RECONNECT_ATTEMPTS) {
                appendToConsole(`Checking if application is available... (attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`, "info");
                setTimeout(connectToConsoleStream, delay);
            } else {
                appendToConsole("Maximum reconnection attempts reached. Please refresh the page manually.", "error");
                stopAvailabilityCheck();
            }
        } else {
            // Normal exponential backoff for non-restart connection issues
            const delay = Math.min(1000 * Math.pow(2, reconnectAttempts - 1), CONFIG.MAX_RECONNECT_DELAY);
            appendToConsole(`Reconnecting in ${delay/1000} seconds (attempt ${reconnectAttempts})...`, "info");
            setTimeout(connectToConsoleStream, delay);
        }
    }
    
    // Function to start checking for application availability
    function startAvailabilityCheck() {
        if (availabilityCheckInterval) {
            clearInterval(availabilityCheckInterval);
        }
        
        // Check server availability every 5 seconds
        availabilityCheckInterval = setInterval(checkServerAvailability, 5000);
    }
    
    // Function to stop checking for application availability
    function stopAvailabilityCheck() {
        if (availabilityCheckInterval) {
            clearInterval(availabilityCheckInterval);
            availabilityCheckInterval = null;
        }
        restartDetected = false;
    }
    
    // Function to check if the server is available
    function checkServerAvailability() {
        fetch('/api/system-info', {
            method: 'GET',
            headers: { 'Cache-Control': 'no-cache' },
            // Add a timestamp to prevent caching
            cache: 'no-store'
        })
        .then(response => {
            if (response.ok) {
                // Server is available again
                appendToConsole("Application is back online! Reconnecting to console stream...", "info");
                stopAvailabilityCheck();
                connectToConsoleStream();
                
                // Reset reconnect attempts
                reconnectAttempts = 0;
                
                // Update system info
                refreshSystemInfo();
                
                // Remove restart notification if it exists
                const restartNotification = document.getElementById('restart-notification');
                if (restartNotification) {
                    restartNotification.remove();
                }
            }
        })
        .catch(error => {
            // Server still unavailable, will try again on next interval
            console.log("Server still unavailable:", error);
        });
    }
    
    // Cache icons for message types (already have consoleOutputElement defined above)
    
    // Cache icons for message types
    const messageIcons = {
        'error': '<i class="fas fa-exclamation-triangle"></i> ',
        'warning': '<i class="fas fa-exclamation-circle"></i> ',
        'info': '<i class="fas fa-info-circle"></i> '
    };
    
    // Use CONFIG.MAX_MESSAGES for consistency
    
    function appendToConsole(message, type) {
        // Get console output element if not cached
        if (!consoleOutputElement) {
            consoleOutputElement = document.getElementById('console-output');
        }
        
        // Store message in our array with a more efficient timestamp
        const now = new Date();
        const timestamp = now.toISOString().replace('T', ' ').substr(0, 19);
        
        const messageObj = {
            message: message,
            type: type,
            timestamp: timestamp
        };
        
        // Add to messages array with limit check - use unshift for better performance when trimming
        // This adds new messages to the beginning of the array, making it faster to trim old messages
        allMessages.unshift(messageObj);
        
        // Trim messages array if it gets too large
        if (allMessages.length > CONFIG.MAX_MESSAGES) {
            allMessages.length = CONFIG.MAX_MESSAGES; // More efficient than slice
        }
        
        // Check if this message should be displayed based on current filter
        if (shouldDisplayMessage(messageObj)) {
            addMessageToDOM(messageObj);
        }
    }
    
    function addMessageToDOM(messageObj) {
        // Get console output element if not cached
        if (!consoleOutputElement) {
            consoleOutputElement = document.getElementById('console-output');
        }
        
        // Create message element
        const messageElement = document.createElement('div');
        messageElement.className = `console-message ${messageObj.type}`;
        
        // Add timestamp
        const timestampSpan = document.createElement('span');
        timestampSpan.className = 'timestamp';
        timestampSpan.textContent = messageObj.timestamp;
        messageElement.appendChild(timestampSpan);
        
        // Add message with appropriate icon
        const icon = messageIcons[messageObj.type] || '';
        
        const messageContent = document.createElement('span');
        messageContent.className = 'message-content';
        
        // Highlight search term if present
        if (searchTerm && messageObj.message.toLowerCase().includes(searchTerm.toLowerCase())) {
            const regex = new RegExp(`(${searchTerm})`, 'gi');
            messageContent.innerHTML = icon + messageObj.message.replace(regex, '<span class="highlight">$1</span>');
        } else {
            messageContent.innerHTML = icon + messageObj.message;
        }
        
        messageElement.appendChild(messageContent);
        
        // Append to console output
        consoleOutputElement.appendChild(messageElement);
        
        // Limit the number of DOM elements to prevent browser slowdown
        if (consoleOutputElement.children.length > CONFIG.MAX_MESSAGES) {
            // Remove oldest messages
            while (consoleOutputElement.children.length > CONFIG.MAX_MESSAGES) {
                consoleOutputElement.removeChild(consoleOutputElement.firstChild);
            }
        }
        
        // Auto-scroll to bottom if enabled
        if (autoScroll) {
            // Use requestAnimationFrame for smoother scrolling
            requestAnimationFrame(scrollToBottom);
        }
    }
    
    function scrollToBottom() {
        // Use cached element if available
        if (!consoleOutputElement) {
            consoleOutputElement = document.getElementById('console-output');
        }
        
        // Use scrollTop for better performance
        consoleOutputElement.scrollTop = consoleOutputElement.scrollHeight;
    }
    
    function clearConsole() {
        // Use cached element if available
        if (!consoleOutputElement) {
            consoleOutputElement = document.getElementById('console-output');
        }
        
        // Clear console with a single operation
        consoleOutputElement.innerHTML = '<div class="console-message text-muted">Console cleared</div>';
        
        // Reset messages array
        allMessages = [];
    }
    
    // Function to refresh the console display based on current filter and search
    function refreshConsoleDisplay() {
        // Use cached element if available
        if (!consoleOutputElement) {
            consoleOutputElement = document.getElementById('console-output');
        }
        
        // Clear current display - use a more efficient method
        while (consoleOutputElement.firstChild) {
            consoleOutputElement.removeChild(consoleOutputElement.firstChild);
        }
        
        // Re-add messages that match the filter and search
        // Use a fragment for better performance
        const fragment = document.createDocumentFragment();
        
        // Count how many messages we're displaying
        let displayCount = 0;
        
        // Since we changed allMessages to add at the beginning (unshift),
        // we can now process in forward order which is more efficient
        for (let i = 0; i < allMessages.length && displayCount < CONFIG.MAX_MESSAGES; i++) {
            if (shouldDisplayMessage(allMessages[i])) {
                // Create message element directly in the fragment
                const messageObj = allMessages[i];
                const messageElement = document.createElement('div');
                messageElement.className = `console-message ${messageObj.type}`;
                
                // Add timestamp
                const timestampSpan = document.createElement('span');
                timestampSpan.className = 'timestamp';
                timestampSpan.textContent = messageObj.timestamp;
                messageElement.appendChild(timestampSpan);
                
                // Add message with appropriate icon
                const icon = messageIcons[messageObj.type] || '';
                
                const messageContent = document.createElement('span');
                messageContent.className = 'message-content';
                
                // Highlight search term if present - use a safer regex approach
                if (searchTerm && messageObj.message.toLowerCase().includes(searchTerm.toLowerCase())) {
                    try {
                        // Escape special regex characters to prevent regex errors
                        const escapedSearchTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                        const regex = new RegExp(`(${escapedSearchTerm})`, 'gi');
                        messageContent.innerHTML = icon + messageObj.message.replace(regex, '<span class="highlight">$1</span>');
                    } catch (e) {
                        // Fallback if regex fails
                        messageContent.innerHTML = icon + messageObj.message;
                    }
                } else {
                    messageContent.innerHTML = icon + messageObj.message;
                }
                
                messageElement.appendChild(messageContent);
                // Add to fragment in chronological order (oldest first)
                fragment.appendChild(messageElement);
                displayCount++;
            }
        }
        
        // Add all elements at once
        consoleOutputElement.appendChild(fragment);
        
        // Auto-scroll to bottom if enabled
        if (autoScroll) {
            requestAnimationFrame(scrollToBottom);
        }
    }
    
    function filterLogs() {
        currentFilter = document.getElementById('log-level-filter').value;
        refreshConsoleDisplay();
    }
    
    function searchLogs() {
        searchTerm = document.getElementById('console-search').value.trim();
        refreshConsoleDisplay();
    }
    
    function shouldDisplayMessage(msg) {
        // Check if message passes the current filter
        if (currentFilter !== 'all' && msg.type !== currentFilter) {
            return false;
        }
        
        // Check if message contains search term
        if (searchTerm && !msg.message.toLowerCase().includes(searchTerm.toLowerCase())) {
            return false;
        }
        
        return true;
    }
    
    function exportLogs() {
        // Create a formatted string of all logs
        let logText = "Cybex Pulse Console Logs - Exported " + new Date().toISOString() + "\n\n";
        
        allMessages.forEach(msg => {
            logText += `[${msg.timestamp}] [${msg.type.toUpperCase()}] ${msg.message}\n`;
        });
        
        // Create a blob and download link
        const blob = new Blob([logText], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = 'cybex-pulse-logs-' + new Date().toISOString().replace(/:/g, '-') + '.txt';
        document.body.appendChild(a);
        a.click();
        
        // Clean up
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
    }
    
    // Clean up event source when leaving the page
    window.addEventListener('beforeunload', function() {
        if (consoleEventSource) {
            consoleEventSource.close();
        }
    });
    
    // Initialize the application
    init();
});
</script>
{% endblock %}

{% block additional_scripts %}
<!-- No additional scripts needed - main script handles everything -->
{% endblock %}