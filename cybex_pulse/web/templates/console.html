{% extends "base.html" %}

{% block title %}Console - Cybex Pulse{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <!-- System Information Cards -->
            <div class="card">
                <div class="card-header">
                    <h3>System Console</h3>
                    <span id="last-updated">Last updated: <span id="update-time-text" class="update-time-text">Just now</span></span>
                </div>
                <div class="grid">
                    <!-- CPU Card -->
                    <div class="stat-card">
                        <div class="stat-icon"><i class="fas fa-microchip"></i></div>
                        <h4>CPU load</h4>
                        <div class="stat-value" id="cpu-usage">{{ system_info.cpu.normalized_load_avg[0]|int if system_info.cpu.normalized_load_avg else system_info.cpu.percent|int }}%</div>
                        <div class="progress-container">
                            <div class="progress-bar" id="cpu-progress" style="width: {{ system_info.cpu.normalized_load_avg[0]|int if system_info.cpu.normalized_load_avg else system_info.cpu.percent|int }}%"></div>
                        </div>
                        <div class="stat-detail">
                            <small>{{ system_info.cpu.count }} cores | {{ system_info.cpu.model }}</small>
                        </div>
                    </div>
                    
                    <!-- Memory Card -->
                    <div class="stat-card">
                        <div class="stat-icon"><i class="fas fa-memory"></i></div>
                        <h4>Memory usage</h4>
                        <div class="stat-value" id="memory-usage">{{ system_info.memory.percent|int }}%</div>
                        <div class="progress-container">
                            <div class="progress-bar" id="memory-progress" style="width: {{ system_info.memory.percent|int }}%"></div>
                        </div>
                        <div class="stat-detail">
                            <small>{{ (system_info.memory.used / 1024 / 1024 / 1024)|round(1) }} GB / {{ (system_info.memory.total / 1024 / 1024 / 1024)|round(1) }} GB</small>
                        </div>
                    </div>
                    
                    <!-- Disk Card -->
                    <div class="stat-card">
                        <div class="stat-icon"><i class="fas fa-hdd"></i></div>
                        <h4>Disk usage</h4>
                        <div class="stat-value" id="disk-usage">{{ system_info.disk.percent|int }}%</div>
                        <div class="progress-container">
                            <div class="progress-bar" id="disk-progress" style="width: {{ system_info.disk.percent|int }}%"></div>
                        </div>
                        <div class="stat-detail">
                            <small>{{ (system_info.disk.used / 1024 / 1024 / 1024)|round(1) if system_info.disk.used else 0 }} GB / {{ (system_info.disk.total / 1024 / 1024 / 1024)|round(1) if system_info.disk.total else 0 }} GB</small>
                        </div>
                    </div>
                </div>
            </div>
            </div>
            
            <!-- Console Output Card -->
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <div class="d-flex align-items-center">
                        <h5 class="mb-0 mr-3">Console Output</h5>
                        <span id="console-status" class="badge badge-primary ml-2">Connected</span>
                    </div>
                    <div class="console-controls">
                        <div class="console-filter">
                            <select id="log-level-filter" class="form-control form-control-sm">
                                <option value="all">All logs</option>
                                <option value="error">Errors only</option>
                                <option value="info">Info only</option>
                            </select>
                        </div>
                        <div class="console-search">
                            <input type="text" id="console-search" class="form-control form-control-sm" placeholder="Search logs...">
                            <button id="search-btn" class="btn btn-sm btn-secondary">
                                <i class="fas fa-search"></i>
                            </button>
                        </div>
                        <div class="autoscroll-toggle">
                            <label class="toggle-switch">
                                <input type="checkbox" id="autoscroll-toggle" checked>
                                <span class="toggle-slider"></span>
                            </label>
                            <span class="toggle-label">Auto-scroll</span>
                        </div>
                    </div>
                </div>
                <div class="card-body">
                    <div id="console-output" class="bg-dark text-light p-3 rounded console-container">
                        <div class="text-muted console-message">Connecting to console stream...</div>
                    </div>
                </div>
                <div class="card-footer">
                    <div class="d-flex justify-content-between">
                        <div>
                            <button id="clear-btn" class="btn btn-secondary" onclick="clearConsole()">
                                <i class="fas fa-trash"></i> Clear Console
                            </button>
                            <button id="export-btn" class="btn btn-secondary ml-2" onclick="exportLogs()">
                                <i class="fas fa-download"></i> Export Logs
                            </button>
                        </div>
                        <button id="back-btn" class="btn btn-secondary" onclick="window.location.href='/'">
                            <i class="fas fa-arrow-left"></i> Back to Dashboard
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Custom styles for console page -->
<style>
    .card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    #last-updated {
        font-size: 0.9rem;
        color: var(--text-muted);
    }
    
    .update-time-text {
        font-weight: 500;
    }
    
    .update-time-normal {
        color: var(--text-color);
    }
    
    .update-time-warning {
        color: var(--yellow);
    }
    
    .progress-container {
        width: 100%;
        height: 8px;
        background-color: var(--border-color);
        border-radius: 4px;
        margin: 10px 0;
        overflow: hidden;
    }
    
    .progress-bar {
        height: 100%;
        border-radius: 4px;
        transition: width 0.5s ease-in-out;
    }
    
    /* Use solid colors instead of gradients for better performance */
    #cpu-progress {
        background-color: var(--green);
    }
    
    #memory-progress {
        background-color: var(--green);
    }
    
    #disk-progress {
        background-color: var(--green);
    }
    
    .console-container {
        height: 500px;
        overflow-y: auto;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        line-height: 1.5;
        padding: 15px;
        position: relative;
    }
    
    .console-message {
        padding: 3px 5px;
        border-radius: 2px;
        margin-bottom: 2px;
        position: relative;
        white-space: pre-wrap;
        word-break: break-word;
    }
    
    .console-message:hover {
        background-color: rgba(255, 255, 255, 0.05);
    }
    
    .console-message.error {
        color: var(--red);
        background-color: rgba(217, 58, 58, 0.1);
        border-left: 3px solid var(--red);
        padding-left: 8px;
    }
    
    .console-message.warning {
        color: var(--yellow);
        background-color: rgba(255, 193, 7, 0.1);
        border-left: 3px solid var(--yellow);
        padding-left: 8px;
    }
    
    .console-message.info {
        color: var(--highlight-blue);
        border-left: 3px solid var(--highlight-blue);
        padding-left: 8px;
    }
    
    .console-message .timestamp {
        color: var(--text-muted);
        font-size: 0.85em;
        margin-right: 8px;
    }
    
    .console-controls {
        display: flex;
        align-items: center;
        gap: 15px;
    }
    
    .console-search {
        display: flex;
        align-items: center;
    }
    
    .console-search input {
        width: 200px;
        margin-right: 5px;
    }
    
    .autoscroll-toggle {
        display: flex;
        align-items: center;
    }
    
    .autoscroll-toggle .toggle-switch {
        margin-right: 5px;
    }
    
    .highlight {
        background-color: rgba(255, 193, 7, 0.3);
        color: white;
        border-radius: 2px;
        padding: 0 2px;
    }
    
    @media (max-width: 768px) {
        .console-controls {
            flex-direction: column;
            align-items: flex-start;
            gap: 10px;
            margin-top: 10px;
        }
        
        .console-search input {
            width: 150px;
        }
        
        .card-header {
            flex-direction: column;
            align-items: flex-start;
        }
        
        .console-filter, .console-search {
            width: 100%;
        }
    }
</style>
{% endblock %}

{% block scripts %}
<script>
    let consoleEventSource = null;
    let autoScroll = true;
    let allMessages = [];
    let currentFilter = 'all';
    let searchTerm = '';
    
    // Deferred loading of console stream
    let streamInitialized = false;
    
    // Variables for restart detection and availability checking
    let restartDetected = false;
    let availabilityCheckInterval = null;
    
    // Track reconnection attempts for exponential backoff and restart detection
    let reconnectAttempts = 0;
    const MAX_RECONNECT_DELAY = 30000; // Maximum reconnect delay of 30 seconds
    const MAX_RECONNECT_ATTEMPTS = 30; // Try for about 5 minutes (10s between attempts)
    
    // Connect to the console stream when the page loads
    document.addEventListener('DOMContentLoaded', function() {
        // Cache DOM elements for better performance
        cacheDOMElements();
        
        // Immediately fetch complete system info to update the initial placeholders
        refreshSystemInfo();
        
        // Defer connecting to the console stream to prioritize UI rendering
        setTimeout(function() {
            connectToConsoleStream();
            streamInitialized = true;
            
            // Ensure console is scrolled to bottom on initial load
            scrollToBottom();
        }, 500);
        
        // Set up periodic refresh of system information (less frequent)
        setInterval(refreshSystemInfo, 10000); // Refresh every 10 seconds
        
        // Initialize last updated time
        updateLastUpdated();
        setInterval(updateLastUpdated, 30000); // Update every 30 seconds
        
        // Initialize progress bars
        updateProgressBars();
        
        // Set up event listeners for controls
        document.getElementById('log-level-filter').addEventListener('change', filterLogs);
        document.getElementById('console-search').addEventListener('input', searchLogs);
        document.getElementById('search-btn').addEventListener('click', searchLogs);
        document.getElementById('autoscroll-toggle').addEventListener('change', function(e) {
            autoScroll = e.target.checked;
            if (autoScroll) {
                scrollToBottom();
            }
        });
        
        // Handle search on enter key
        document.getElementById('console-search').addEventListener('keyup', function(e) {
            if (e.key === 'Enter') {
                searchLogs();
            }
        });
        
        // Initialize progress bars
        updateProgressBars();
        
        // Variables to track user scrolling vs. content additions
        let lastScrollHeight = 0;
        let userScrolledUp = false;
        let scrollTimeout = null;
        
        // Handle console scrolling to detect manual scroll
        const consoleOutput = document.getElementById('console-output');
        
        // Initialize the last scroll height
        setTimeout(() => {
            lastScrollHeight = consoleOutput.scrollHeight;
        }, 500);
        
        consoleOutput.addEventListener('scroll', function() {
            // Clear any pending scroll timeout
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
            }
            
            // Calculate how far from the bottom we are
            const scrollBottom = consoleOutput.scrollHeight - consoleOutput.scrollTop - consoleOutput.clientHeight;
            
            // If the scroll height hasn't changed, this is a user-initiated scroll
            if (consoleOutput.scrollHeight === lastScrollHeight) {
                // User scrolled up if we're more than 50px from bottom
                userScrolledUp = scrollBottom > 50;
                
                // If user scrolled up, disable auto-scroll
                if (userScrolledUp && autoScroll) {
                    document.getElementById('autoscroll-toggle').checked = false;
                    autoScroll = false;
                }
                
                // If user scrolled to bottom, re-enable auto-scroll if toggle is checked
                if (scrollBottom < 10 && !autoScroll && document.getElementById('autoscroll-toggle').checked) {
                    autoScroll = true;
                }
            } else {
                // Content was added, update the last scroll height
                lastScrollHeight = consoleOutput.scrollHeight;
                
                // If auto-scroll is enabled, scroll to bottom after a short delay
                if (autoScroll) {
                    scrollTimeout = setTimeout(scrollToBottom, 50);
                }
            }
        });
    });
    
    // Function to update the "last updated" time
    function updateLastUpdated() {
        const updateTimeElement = document.getElementById('update-time-text');
        const now = new Date();
        const lastUpdate = window.lastUpdateTime || now;
        window.lastUpdateTime = now;
        
        const diffInSeconds = Math.floor((now - lastUpdate) / 1000);
        
        let text = 'Just now';
        let className = 'update-time-normal';
        
        if (diffInSeconds < 60) {
            text = 'Just now';
        } else if (diffInSeconds < 300) {
            text = 'Less than 5 minutes ago';
        } else {
            text = 'Over 5 minutes ago';
            className = 'update-time-warning';
        }
        
        updateTimeElement.textContent = text;
        updateTimeElement.className = 'update-time-text ' + className;
    }
    
    // Cache DOM elements for better performance
    let domElements = {};
    
    // Function to cache DOM elements on page load
    function cacheDOMElements() {
        domElements = {
            cpuUsage: document.getElementById('cpu-usage'),
            cpuProgress: document.getElementById('cpu-progress'),
            cpuDetail: document.querySelector('.stat-card:first-child .stat-detail small'),
            memoryUsage: document.getElementById('memory-usage'),
            memoryProgress: document.getElementById('memory-progress'),
            memoryDetail: document.querySelector('.stat-card:nth-child(2) .stat-detail small'),
            diskUsage: document.getElementById('disk-usage'),
            diskProgress: document.getElementById('disk-progress'),
            diskDetail: document.querySelector('.stat-card:nth-child(3) .stat-detail small'),
            uptimeValue: document.getElementById('uptime-value')
        };
    }
    
    // Function to refresh system information with debouncing and parallel requests
    let refreshInProgress = false;
    function refreshSystemInfo() {
        // Prevent multiple simultaneous requests
        if (refreshInProgress) return;
        
        refreshInProgress = true;
        
        // Use separate API endpoints for each metric to reduce load
        // This allows partial updates if one endpoint is slow
        Promise.all([
            fetch('/api/system-info/cpu').then(response => response.json()),
            fetch('/api/system-info/memory').then(response => response.json()),
            fetch('/api/system-info/disk').then(response => response.json())
        ])
        .then(([cpuData, memoryData, diskData]) => {
            // Combine the data
            const data = {
                cpu: cpuData,
                memory: memoryData,
                disk: diskData
            };
            
            updateSystemInfoCards(data);
            updateProgressBars();
            updateLastUpdated();
            refreshInProgress = false;
        })
        .catch(error => {
            console.error('Error fetching system info:', error);
            refreshInProgress = false;
            
            // Schedule a retry after a delay
            setTimeout(refreshSystemInfo, 5000);
        });
    }
    
    // Function to update system information cards
    function updateSystemInfoCards(data) {
        // Ensure DOM elements are cached
        if (!domElements.cpuUsage) {
            cacheDOMElements();
        }
        
        // Update CPU card with 1-minute load average (rounded to integer)
        if (data.cpu) {
            const cpuValue = data.cpu.normalized_load_avg ? data.cpu.normalized_load_avg[0] : data.cpu.percent;
            const cpuRounded = Math.round(cpuValue);
            
            if (domElements.cpuUsage) domElements.cpuUsage.textContent = cpuRounded + '%';
            if (domElements.cpuProgress) domElements.cpuProgress.style.width = cpuRounded + '%';
            
            // Update CPU details
            if (domElements.cpuDetail && data.cpu.count && data.cpu.model) {
                domElements.cpuDetail.textContent = `${data.cpu.count} cores | ${data.cpu.model}`;
            }
        }
        
        // Update Memory card (rounded to integer)
        if (data.memory) {
            const memRounded = Math.round(data.memory.percent);
            
            if (domElements.memoryUsage) domElements.memoryUsage.textContent = memRounded + '%';
            if (domElements.memoryProgress) domElements.memoryProgress.style.width = memRounded + '%';
            
            // Update memory details
            if (domElements.memoryDetail && data.memory.used && data.memory.total) {
                const usedGB = (data.memory.used / 1024 / 1024 / 1024).toFixed(1);
                const totalGB = (data.memory.total / 1024 / 1024 / 1024).toFixed(1);
                domElements.memoryDetail.textContent = `${usedGB} GB / ${totalGB} GB`;
            }
        }
        
        // Update Disk card (rounded to integer)
        if (data.disk) {
            const diskRounded = Math.round(data.disk.percent);
            
            if (domElements.diskUsage) domElements.diskUsage.textContent = diskRounded + '%';
            if (domElements.diskProgress) domElements.diskProgress.style.width = diskRounded + '%';
            
            // Update disk details
            if (domElements.diskDetail && data.disk.used && data.disk.total) {
                const usedGB = (data.disk.used / 1024 / 1024 / 1024).toFixed(1);
                const totalGB = (data.disk.total / 1024 / 1024 / 1024).toFixed(1);
                domElements.diskDetail.textContent = `${usedGB} GB / ${totalGB} GB`;
            }
        }
        
        // Update uptime if available
        if (data.uptime && data.uptime.uptime_formatted && domElements.uptimeValue) {
            domElements.uptimeValue.textContent = data.uptime.uptime_formatted;
        }
    }
    
    // Function to update progress bar colors based on values
    function updateProgressBars() {
        const cpuProgress = document.getElementById('cpu-progress');
        const memoryProgress = document.getElementById('memory-progress');
        const diskProgress = document.getElementById('disk-progress');
        
        // Get current values
        const cpuValue = parseInt(cpuProgress.style.width) || 0;
        const memoryValue = parseInt(memoryProgress.style.width) || 0;
        const diskValue = parseInt(diskProgress.style.width) || 0;
        
        // Set colors based on values
        if (cpuValue < 50) {
            cpuProgress.style.backgroundColor = 'var(--green)';
        } else if (cpuValue < 80) {
            cpuProgress.style.backgroundColor = 'var(--yellow)';
        } else {
            cpuProgress.style.backgroundColor = 'var(--red)';
        }
        
        if (memoryValue < 50) {
            memoryProgress.style.backgroundColor = 'var(--green)';
        } else if (memoryValue < 80) {
            memoryProgress.style.backgroundColor = 'var(--yellow)';
        } else {
            memoryProgress.style.backgroundColor = 'var(--red)';
        }
        
        if (diskValue < 50) {
            diskProgress.style.backgroundColor = 'var(--green)';
        } else if (diskValue < 80) {
            diskProgress.style.backgroundColor = 'var(--yellow)';
        } else {
            diskProgress.style.backgroundColor = 'var(--red)';
        }
    }
    
    // Cache DOM elements for console status
    let consoleStatusElement = null;
    
    // Function to connect to the console stream
    function connectToConsoleStream() {
        // Cache console status element
        if (!consoleStatusElement) {
            consoleStatusElement = document.getElementById('console-status');
        }
        
        // Close any existing connection
        if (consoleEventSource) {
            consoleEventSource.close();
            consoleEventSource = null;
        }
        
        // Update status to connecting
        if (consoleStatusElement) {
            consoleStatusElement.textContent = 'Connecting...';
            consoleStatusElement.className = 'badge badge-warning';
        }
        
        // Connect to the SSE endpoint
        try {
            consoleEventSource = new EventSource('/console-stream');
            
            // Handle connection open
            consoleEventSource.onopen = function() {
                // Reset reconnect attempts on successful connection
                reconnectAttempts = 0;
                
                if (consoleStatusElement) {
                    consoleStatusElement.textContent = 'Connected';
                    consoleStatusElement.className = 'badge badge-success';
                }
                appendToConsole("Connected to console stream", "info");
            };
            
            // Handle messages with batching for better performance
            let messageQueue = [];
            let processingQueue = false;
            
            consoleEventSource.addEventListener('message', function(event) {
                try {
                    const data = JSON.parse(event.data);
                    
                    // Check if this is a restart message
                    if (data.message && (
                        data.message.includes("restart") ||
                        data.message.includes("Restart") ||
                        data.message.includes("restarting") ||
                        data.message.includes("Restarting")
                    )) {
                        // Mark restart as detected
                        restartDetected = true;
                        
                        // Add a more informative message to the queue
                        messageQueue.push({
                            message: data.message,
                            type: data.is_error ? "error" : "info"
                        });
                        
                        // Add our own message about waiting for the application
                        messageQueue.push({
                            message: "Application is restarting. Please wait while the system comes back online...",
                            type: "info"
                        });
                        
                        // Start checking for application availability
                        startAvailabilityCheck();
                    } else {
                        // Regular message, add to queue
                        messageQueue.push({
                            message: data.message,
                            type: data.is_error ? "error" : "info"
                        });
                    }
                    
                    // Process queue if not already processing
                    if (!processingQueue) {
                        processMessageQueue();
                    }
                } catch (e) {
                    appendToConsole("Error parsing message: " + e.message, "error");
                }
            });
            
            // Function to process message queue with requestAnimationFrame for better UI performance
            function processMessageQueue() {
                processingQueue = true;
                
                requestAnimationFrame(function() {
                    // Process up to 20 messages at a time (increased from 10)
                    const messagesToProcess = messageQueue.splice(0, 20);
                    
                    if (messagesToProcess.length > 0) {
                        // Add messages to console
                        messagesToProcess.forEach(msg => {
                            appendToConsole(msg.message, msg.type);
                        });
                        
                        // If more messages in queue, continue processing
                        if (messageQueue.length > 0) {
                            processMessageQueue();
                        } else {
                            processingQueue = false;
                        }
                    } else {
                        processingQueue = false;
                    }
                });
            }
        } catch (e) {
            appendToConsole("Failed to connect to console stream: " + e.message, "error");
            if (consoleStatusElement) {
                consoleStatusElement.textContent = 'Connection Failed';
                consoleStatusElement.className = 'badge badge-danger';
            }
            scheduleReconnect();
        }
        
        // Handle errors with improved error handling
        consoleEventSource.addEventListener('error', function(event) {
            if (event.data) {
                try {
                    const data = JSON.parse(event.data);
                    appendToConsole(data.message, "error");
                } catch (e) {
                    // Silently ignore parsing errors
                }
            }
        });
        
        // Handle connection errors with cached DOM element and exponential backoff
        consoleEventSource.onerror = function(event) {
            // Check if the connection was never established
            if (consoleEventSource.readyState === 0) {
                appendToConsole('Failed to connect to console stream. Will retry automatically.', "error");
                if (consoleStatusElement) {
                    consoleStatusElement.textContent = 'Connection Failed';
                    consoleStatusElement.className = 'badge badge-danger';
                }
                scheduleReconnect();
            }
            // Check if the connection was lost after being established
            else if (consoleEventSource.readyState === 2) {
                // If we detect a message about restarting, mark as restart detected
                if (!restartDetected) {
                    appendToConsole('Connection to console stream lost. This may be due to application restart.', "warning");
                    appendToConsole('Waiting for application to become available again...', "info");
                    restartDetected = true;
                    
                    // Start checking for application availability
                    startAvailabilityCheck();
                } else {
                    appendToConsole('Connection to console stream lost. Attempting to reconnect...', "warning");
                }
                
                if (consoleStatusElement) {
                    consoleStatusElement.textContent = 'Disconnected';
                    consoleStatusElement.className = 'badge badge-warning';
                }
                scheduleReconnect();
            }
        };
    }
    
    // Function to schedule reconnection with exponential backoff
    function scheduleReconnect() {
        reconnectAttempts++;
        
        // If we've detected a restart, use a fixed interval instead of exponential backoff
        if (restartDetected) {
            const delay = 10000; // Fixed 10 second delay during restart
            
            if (reconnectAttempts <= MAX_RECONNECT_ATTEMPTS) {
                appendToConsole(`Checking if application is available... (attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`, "info");
                setTimeout(connectToConsoleStream, delay);
            } else {
                appendToConsole("Maximum reconnection attempts reached. Please refresh the page manually.", "error");
                stopAvailabilityCheck();
            }
        } else {
            // Normal exponential backoff for non-restart connection issues
            const delay = Math.min(1000 * Math.pow(2, reconnectAttempts - 1), MAX_RECONNECT_DELAY);
            appendToConsole(`Reconnecting in ${delay/1000} seconds (attempt ${reconnectAttempts})...`, "info");
            setTimeout(connectToConsoleStream, delay);
        }
    }
    
    // Function to start checking for application availability
    function startAvailabilityCheck() {
        if (availabilityCheckInterval) {
            clearInterval(availabilityCheckInterval);
        }
        
        // Check server availability every 5 seconds
        availabilityCheckInterval = setInterval(checkServerAvailability, 5000);
    }
    
    // Function to stop checking for application availability
    function stopAvailabilityCheck() {
        if (availabilityCheckInterval) {
            clearInterval(availabilityCheckInterval);
            availabilityCheckInterval = null;
        }
        restartDetected = false;
    }
    
    // Function to check if the server is available
    function checkServerAvailability() {
        fetch('/api/system-info', {
            method: 'GET',
            headers: { 'Cache-Control': 'no-cache' },
            // Add a timestamp to prevent caching
            cache: 'no-store'
        })
        .then(response => {
            if (response.ok) {
                // Server is available again
                appendToConsole("Application is back online! Reconnecting to console stream...", "info");
                stopAvailabilityCheck();
                connectToConsoleStream();
                
                // Reset reconnect attempts
                reconnectAttempts = 0;
                
                // Update system info
                refreshSystemInfo();
            }
        })
        .catch(error => {
            // Server still unavailable, will try again on next interval
            console.log("Server still unavailable:", error);
        });
    }
    
    // Cache DOM elements for console output
    let consoleOutputElement = null;
    
    // Cache icons for message types
    const messageIcons = {
        'error': '<i class="fas fa-exclamation-triangle"></i> ',
        'warning': '<i class="fas fa-exclamation-circle"></i> ',
        'info': '<i class="fas fa-info-circle"></i> '
    };
    
    // Limit the number of messages to prevent memory issues
    const MAX_MESSAGES = 500; // Reduced from 1000 to 500 to improve performance
    
    function appendToConsole(message, type) {
        // Get console output element if not cached
        if (!consoleOutputElement) {
            consoleOutputElement = document.getElementById('console-output');
        }
        
        // Store message in our array with a more efficient timestamp
        const now = new Date();
        const timestamp = now.toISOString().replace('T', ' ').substr(0, 19);
        
        const messageObj = {
            message: message,
            type: type,
            timestamp: timestamp
        };
        
        // Add to messages array with limit check - use unshift for better performance when trimming
        // This adds new messages to the beginning of the array, making it faster to trim old messages
        allMessages.unshift(messageObj);
        
        // Trim messages array if it gets too large
        if (allMessages.length > MAX_MESSAGES) {
            allMessages.length = MAX_MESSAGES; // More efficient than slice
        }
        
        // Check if this message should be displayed based on current filter
        if (shouldDisplayMessage(messageObj)) {
            addMessageToDOM(messageObj);
        }
    }
    
    function addMessageToDOM(messageObj) {
        // Get console output element if not cached
        if (!consoleOutputElement) {
            consoleOutputElement = document.getElementById('console-output');
        }
        
        // Create message element
        const messageElement = document.createElement('div');
        messageElement.className = `console-message ${messageObj.type}`;
        
        // Add timestamp
        const timestampSpan = document.createElement('span');
        timestampSpan.className = 'timestamp';
        timestampSpan.textContent = messageObj.timestamp;
        messageElement.appendChild(timestampSpan);
        
        // Add message with appropriate icon
        const icon = messageIcons[messageObj.type] || '';
        
        const messageContent = document.createElement('span');
        messageContent.className = 'message-content';
        
        // Highlight search term if present
        if (searchTerm && messageObj.message.toLowerCase().includes(searchTerm.toLowerCase())) {
            const regex = new RegExp(`(${searchTerm})`, 'gi');
            messageContent.innerHTML = icon + messageObj.message.replace(regex, '<span class="highlight">$1</span>');
        } else {
            messageContent.innerHTML = icon + messageObj.message;
        }
        
        messageElement.appendChild(messageContent);
        
        // Append to console output
        consoleOutputElement.appendChild(messageElement);
        
        // Limit the number of DOM elements to prevent browser slowdown
        if (consoleOutputElement.children.length > MAX_MESSAGES) {
            // Remove oldest messages
            while (consoleOutputElement.children.length > MAX_MESSAGES) {
                consoleOutputElement.removeChild(consoleOutputElement.firstChild);
            }
        }
        
        // Auto-scroll to bottom if enabled
        if (autoScroll) {
            // Use requestAnimationFrame for smoother scrolling
            requestAnimationFrame(scrollToBottom);
        }
    }
    
    function scrollToBottom() {
        // Use cached element if available
        if (!consoleOutputElement) {
            consoleOutputElement = document.getElementById('console-output');
        }
        
        // Use scrollTop for better performance
        consoleOutputElement.scrollTop = consoleOutputElement.scrollHeight;
    }
    
    function clearConsole() {
        // Use cached element if available
        if (!consoleOutputElement) {
            consoleOutputElement = document.getElementById('console-output');
        }
        
        // Clear console with a single operation
        consoleOutputElement.innerHTML = '<div class="console-message text-muted">Console cleared</div>';
        
        // Reset messages array
        allMessages = [];
    }
    
    // Function to refresh the console display based on current filter and search
    function refreshConsoleDisplay() {
        // Use cached element if available
        if (!consoleOutputElement) {
            consoleOutputElement = document.getElementById('console-output');
        }
        
        // Clear current display - use a more efficient method
        while (consoleOutputElement.firstChild) {
            consoleOutputElement.removeChild(consoleOutputElement.firstChild);
        }
        
        // Re-add messages that match the filter and search
        // Use a fragment for better performance
        const fragment = document.createDocumentFragment();
        
        // Count how many messages we're displaying
        let displayCount = 0;
        
        // Since we changed allMessages to add at the beginning (unshift),
        // we can now process in forward order which is more efficient
        for (let i = 0; i < allMessages.length && displayCount < MAX_MESSAGES; i++) {
            if (shouldDisplayMessage(allMessages[i])) {
                // Create message element directly in the fragment
                const messageObj = allMessages[i];
                const messageElement = document.createElement('div');
                messageElement.className = `console-message ${messageObj.type}`;
                
                // Add timestamp
                const timestampSpan = document.createElement('span');
                timestampSpan.className = 'timestamp';
                timestampSpan.textContent = messageObj.timestamp;
                messageElement.appendChild(timestampSpan);
                
                // Add message with appropriate icon
                const icon = messageIcons[messageObj.type] || '';
                
                const messageContent = document.createElement('span');
                messageContent.className = 'message-content';
                
                // Highlight search term if present - use a safer regex approach
                if (searchTerm && messageObj.message.toLowerCase().includes(searchTerm.toLowerCase())) {
                    try {
                        // Escape special regex characters to prevent regex errors
                        const escapedSearchTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                        const regex = new RegExp(`(${escapedSearchTerm})`, 'gi');
                        messageContent.innerHTML = icon + messageObj.message.replace(regex, '<span class="highlight">$1</span>');
                    } catch (e) {
                        // Fallback if regex fails
                        messageContent.innerHTML = icon + messageObj.message;
                    }
                } else {
                    messageContent.innerHTML = icon + messageObj.message;
                }
                
                messageElement.appendChild(messageContent);
                // Add to fragment in chronological order (oldest first)
                fragment.appendChild(messageElement);
                displayCount++;
            }
        }
        
        // Add all elements at once
        consoleOutputElement.appendChild(fragment);
        
        // Auto-scroll to bottom if enabled
        if (autoScroll) {
            requestAnimationFrame(scrollToBottom);
        }
    }
    
    function filterLogs() {
        currentFilter = document.getElementById('log-level-filter').value;
        refreshConsoleDisplay();
    }
    
    function searchLogs() {
        searchTerm = document.getElementById('console-search').value.trim();
        refreshConsoleDisplay();
    }
    
    function shouldDisplayMessage(msg) {
        // Check if message passes the current filter
        if (currentFilter !== 'all' && msg.type !== currentFilter) {
            return false;
        }
        
        // Check if message contains search term
        if (searchTerm && !msg.message.toLowerCase().includes(searchTerm.toLowerCase())) {
            return false;
        }
        
        return true;
    }
    
    function exportLogs() {
        // Create a formatted string of all logs
        let logText = "Cybex Pulse Console Logs - Exported " + new Date().toISOString() + "\n\n";
        
        allMessages.forEach(msg => {
            logText += `[${msg.timestamp}] [${msg.type.toUpperCase()}] ${msg.message}\n`;
        });
        
        // Create a blob and download link
        const blob = new Blob([logText], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = 'cybex-pulse-logs-' + new Date().toISOString().replace(/:/g, '-') + '.txt';
        document.body.appendChild(a);
        a.click();
        
        // Clean up
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
    }
    
    // Clean up event source when leaving the page
    window.addEventListener('beforeunload', function() {
        if (consoleEventSource) {
            consoleEventSource.close();
        }
    });
</script>
{% endblock %}